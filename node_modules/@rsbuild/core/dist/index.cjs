"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/client/format.ts
function resolveFileName(stats) {
  if (stats.moduleIdentifier) {
    const regex = /(?:\!|^)([^!]+)$/;
    const matched = stats.moduleIdentifier.match(regex);
    if (matched) {
      const fileName = matched.pop();
      if (fileName) {
        return `File: ${fileName}:1:1
`;
      }
    }
  }
  return stats.moduleName ? `File: ${stats.moduleName}
` : "";
}
function hintUnknownFiles(message) {
  const hint = "You may need an appropriate loader to handle this file type.";
  if (message.indexOf(hint) === -1) {
    return message;
  }
  if (/File: .+\.s(c|a)ss/.test(message)) {
    return message.replace(
      hint,
      `To enable support for Sass, use "@rsbuild/plugin-sass".`
    );
  }
  if (/File: .+\.less/.test(message)) {
    return message.replace(
      hint,
      `To enable support for Less, use "@rsbuild/plugin-less".`
    );
  }
  if (/File: .+\.styl(us)?/.test(message)) {
    return message.replace(
      hint,
      `To enable support for Stylus, use "@rsbuild/plugin-stylus".`
    );
  }
  return message;
}
function formatMessage(stats, verbose) {
  let lines = [];
  let message;
  if (typeof stats === "object") {
    const fileName = resolveFileName(stats);
    const mainMessage = stats.message;
    const details = verbose && stats.details ? `
Details: ${stats.details}
` : "";
    const stack = verbose && stats.stack ? `
${stats.stack}` : "";
    message = `${fileName}${mainMessage}${details}${stack}`;
  } else {
    message = stats;
  }
  message = hintUnknownFiles(message);
  lines = message.split("\n");
  lines = lines.filter(
    (line, index, arr) => index === 0 || line.trim() !== "" || line.trim() !== arr[index - 1].trim()
  );
  message = lines.join("\n");
  const innerError = "-- inner error --";
  if (!verbose && message.includes(innerError)) {
    message = message.split(innerError)[0];
  }
  return message.trim();
}
function formatStatsMessages(stats, verbose) {
  const formattedErrors = stats.errors?.map((error) => formatMessage(error, verbose)) || [];
  const formattedWarnings = stats.warnings?.map((warning) => formatMessage(warning, verbose)) || [];
  return {
    errors: formattedErrors,
    warnings: formattedWarnings
  };
}
var init_format = __esm({
  "src/client/format.ts"() {
    "use strict";
  }
});

// src/constants.ts
var import_node_path, ROOT_DIST_DIR, HTML_DIST_DIR, SERVER_DIST_DIR, SERVICE_WORKER_DIST_DIR, JS_DIST_DIR, CSS_DIST_DIR, SVG_DIST_DIR, FONT_DIST_DIR, WASM_DIST_DIR, IMAGE_DIST_DIR, MEDIA_DIST_DIR, LOADER_PATH, STATIC_PATH, COMPILED_PATH, TS_CONFIG_FILE, DEFAULT_PORT, DEFAULT_DATA_URL_SIZE, DEFAULT_MOUNT_ID, DEFAULT_DEV_HOST, HTML_REGEX, CSS_REGEX, PLUGIN_SWC_NAME, PLUGIN_CSS_NAME, FONT_EXTENSIONS, IMAGE_EXTENSIONS, VIDEO_EXTENSIONS, AUDIO_EXTENSIONS;
var init_constants = __esm({
  "src/constants.ts"() {
    "use strict";
    import_node_path = require("path");
    ROOT_DIST_DIR = "dist";
    HTML_DIST_DIR = "/";
    SERVER_DIST_DIR = "server";
    SERVICE_WORKER_DIST_DIR = "worker";
    JS_DIST_DIR = "static/js";
    CSS_DIST_DIR = "static/css";
    SVG_DIST_DIR = "static/svg";
    FONT_DIST_DIR = "static/font";
    WASM_DIST_DIR = "static/wasm";
    IMAGE_DIST_DIR = "static/image";
    MEDIA_DIST_DIR = "static/media";
    LOADER_PATH = (0, import_node_path.join)(__dirname);
    STATIC_PATH = (0, import_node_path.join)(__dirname, "../static");
    COMPILED_PATH = (0, import_node_path.join)(__dirname, "../compiled");
    TS_CONFIG_FILE = "tsconfig.json";
    DEFAULT_PORT = 3e3;
    DEFAULT_DATA_URL_SIZE = 4096;
    DEFAULT_MOUNT_ID = "root";
    DEFAULT_DEV_HOST = "0.0.0.0";
    HTML_REGEX = /\.html$/;
    CSS_REGEX = /\.css$/;
    PLUGIN_SWC_NAME = "rsbuild:swc";
    PLUGIN_CSS_NAME = "rsbuild:css";
    FONT_EXTENSIONS = ["woff", "woff2", "eot", "ttf", "otf", "ttc"];
    IMAGE_EXTENSIONS = [
      "png",
      "jpg",
      "jpeg",
      "pjpeg",
      "pjp",
      "gif",
      "bmp",
      "webp",
      "ico",
      "apng",
      "avif",
      "tif",
      "tiff",
      "jfif"
    ];
    VIDEO_EXTENSIONS = ["mp4", "webm", "ogg", "mov"];
    AUDIO_EXTENSIONS = ["mp3", "wav", "flac", "aac", "m4a", "opus"];
  }
});

// src/helpers.ts
function formatErrorMessage(errors) {
  const messages = errors.map((error) => hintNodePolyfill(error));
  const text = `${messages.join("\n\n")}
`;
  const isTerserError = text.includes("from Terser");
  const title = import_shared.color.bold(
    import_shared.color.red(isTerserError ? "Minify error: " : "Compile error: ")
  );
  if (!errors.length) {
    return `${title}
${import_shared.color.yellow(`For more details, please setting 'stats.errors: true' `)}`;
  }
  const tip = import_shared.color.yellow(
    isTerserError ? "Failed to minify with terser, check for syntax errors." : "Failed to compile, check the errors for troubleshooting."
  );
  return `${title}
${tip}
${text}`;
}
function getStatsOptions(compiler) {
  if ((0, import_shared.isMultiCompiler)(compiler)) {
    return {
      children: compiler.compilers.map(
        (compiler2) => compiler2.options ? compiler2.options.stats : void 0
      )
    };
  }
  return compiler.options ? compiler.options.stats : void 0;
}
function formatStats(stats, options = {}) {
  const statsData = stats.toJson(
    typeof options === "object" ? {
      preset: "errors-warnings",
      children: true,
      ...options
    } : options
  );
  const { errors, warnings } = formatStatsMessages(
    {
      errors: getAllStatsErrors(statsData),
      warnings: getAllStatsWarnings(statsData)
    },
    // display verbose messages in prod build or debug mode
    (0, import_shared.isProd)() || (0, import_shared.isDebug)()
  );
  if (stats.hasErrors()) {
    return {
      message: formatErrorMessage(errors),
      level: "error"
    };
  }
  if (warnings.length) {
    const title = import_shared.color.bold(import_shared.color.yellow("Compile Warning: \n"));
    return {
      message: `${title}${warnings.join("\n\n")}
`,
      level: "warning"
    };
  }
  return {};
}
function isEmptyDir(path13) {
  const files = import_shared2.fse.readdirSync(path13);
  return files.length === 0 || files.length === 1 && files[0] === ".git";
}
async function isFileExists(file) {
  return import_shared2.fse.promises.access(file, import_shared2.fse.constants.F_OK).then(() => true).catch(() => false);
}
var import_node_path2, import_shared, import_shared2, rspackMinVersion, compareSemver, isSatisfyRspackVersion, getCompiledPath, hintNodePolyfill, getAllStatsErrors, getAllStatsWarnings, formatPublicPath, getPublicPathFromChain, ensureAbsolutePath, isFileSync, findExists;
var init_helpers = __esm({
  "src/helpers.ts"() {
    "use strict";
    import_node_path2 = __toESM(require("path"));
    import_shared = require("@rsbuild/shared");
    import_shared2 = require("@rsbuild/shared");
    init_format();
    init_constants();
    rspackMinVersion = "0.6.2";
    compareSemver = (version1, version2) => {
      const parts1 = version1.split(".").map(Number);
      const parts2 = version2.split(".").map(Number);
      const len = Math.max(parts1.length, parts2.length);
      for (let i = 0; i < len; i++) {
        const item1 = parts1[i] ?? 0;
        const item2 = parts2[i] ?? 0;
        if (item1 > item2) {
          return 1;
        }
        if (item1 < item2) {
          return -1;
        }
      }
      return 0;
    };
    isSatisfyRspackVersion = async (originalVersion) => {
      let version2 = originalVersion;
      if (version2.includes("-canary")) {
        version2 = version2.split("-canary")[0];
      }
      if (version2 && /^[\d\.]+$/.test(version2)) {
        return compareSemver(version2, rspackMinVersion) >= 0;
      }
      return true;
    };
    getCompiledPath = (packageName) => import_node_path2.default.join(COMPILED_PATH, packageName);
    hintNodePolyfill = (message) => {
      if (!message.includes(`Can't resolve`)) {
        return message;
      }
      const matchArray = message.match(/Can't resolve '(\w+)'/);
      if (!matchArray) {
        return message;
      }
      const moduleName = matchArray[1];
      const nodeModules = [
        "assert",
        "buffer",
        "child_process",
        "cluster",
        "console",
        "constants",
        "crypto",
        "dgram",
        "dns",
        "domain",
        "events",
        "fs",
        "http",
        "https",
        "module",
        "net",
        "os",
        "path",
        "punycode",
        "process",
        "querystring",
        "readline",
        "repl",
        "stream",
        "_stream_duplex",
        "_stream_passthrough",
        "_stream_readable",
        "_stream_transform",
        "_stream_writable",
        "string_decoder",
        "sys",
        "timers",
        "tls",
        "tty",
        "url",
        "util",
        "vm",
        "zlib"
      ];
      if (moduleName && nodeModules.includes(moduleName)) {
        const tips = [
          `Tip: "${moduleName}" is a built-in Node.js module and cannot be imported in client-side code.`,
          `Check if you need to import Node.js module. If needed, you can use "@rsbuild/plugin-node-polyfill".`
        ];
        return `${message}

${import_shared.color.yellow(tips.join("\n"))}`;
      }
      return message;
    };
    getAllStatsErrors = (statsData) => {
      if (statsData.errorsCount && statsData.errors?.length === 0) {
        return statsData.children?.reduce(
          (errors, curr) => errors.concat(curr.errors || []),
          []
        );
      }
      return statsData.errors;
    };
    getAllStatsWarnings = (statsData) => {
      if (statsData.warningsCount && statsData.warnings?.length === 0) {
        return statsData.children?.reduce(
          (warnings, curr) => warnings.concat(curr.warnings || []),
          []
        );
      }
      return statsData.warnings;
    };
    formatPublicPath = (publicPath, withSlash = true) => {
      if (publicPath === "auto") {
        return publicPath;
      }
      return withSlash ? (0, import_shared.addTrailingSlash)(publicPath) : (0, import_shared.removeTailingSlash)(publicPath);
    };
    getPublicPathFromChain = (chain, withSlash = true) => {
      const publicPath = chain.output.get("publicPath");
      if (typeof publicPath === "string") {
        return formatPublicPath(publicPath, withSlash);
      }
      return formatPublicPath(import_shared.DEFAULT_ASSET_PREFIX, withSlash);
    };
    ensureAbsolutePath = (base, filePath) => import_node_path2.default.isAbsolute(filePath) ? filePath : import_node_path2.default.resolve(base, filePath);
    isFileSync = (filePath) => {
      try {
        return import_shared2.fse.statSync(filePath, { throwIfNoEntry: false })?.isFile();
      } catch (_) {
        return false;
      }
    };
    findExists = (files) => {
      for (const file of files) {
        if (isFileSync(file)) {
          return file;
        }
      }
      return false;
    };
  }
});

// src/mergeConfig.ts
var import_shared3, OVERRIDE_PATH, isOverridePath, merge, mergeRsbuildConfig;
var init_mergeConfig = __esm({
  "src/mergeConfig.ts"() {
    "use strict";
    import_shared3 = require("@rsbuild/shared");
    OVERRIDE_PATH = [
      "performance.removeConsole",
      "output.inlineScripts",
      "output.inlineStyles",
      "output.cssModules.auto",
      "output.targets",
      "output.emitAssets",
      "server.open",
      "server.printUrls",
      "dev.startUrl",
      "provider"
    ];
    isOverridePath = (key) => OVERRIDE_PATH.includes(key);
    merge = (x, y, path13 = "") => {
      if (isOverridePath(path13)) {
        return y ?? x;
      }
      if (x === void 0) {
        return y;
      }
      if (y === void 0) {
        return x;
      }
      const pair = [x, y];
      if (pair.some(Array.isArray)) {
        return [...(0, import_shared3.castArray)(x), ...(0, import_shared3.castArray)(y)];
      }
      if (pair.some(import_shared3.isFunction)) {
        return pair;
      }
      if (!(0, import_shared3.isPlainObject)(x) || !(0, import_shared3.isPlainObject)(y)) {
        return y;
      }
      const merged = {};
      const keys = /* @__PURE__ */ new Set([...Object.keys(x), ...Object.keys(y)]);
      for (const key of keys) {
        const childPath = path13 ? `${path13}.${key}` : key;
        merged[key] = merge(x[key], y[key], childPath);
      }
      return merged;
    };
    mergeRsbuildConfig = (...configs) => {
      if (configs.length === 2) {
        return merge(configs[0], configs[1]);
      }
      if (configs.length < 2) {
        return configs[0];
      }
      return configs.reduce(
        (result, config) => merge(result, config),
        {}
      );
    };
  }
});

// src/server/restart.ts
var import_node_path3, import_shared4, cleaners, onBeforeRestartServer, clearConsole, restartDevServer;
var init_restart = __esm({
  "src/server/restart.ts"() {
    "use strict";
    import_node_path3 = __toESM(require("path"));
    import_shared4 = require("@rsbuild/shared");
    init_init();
    cleaners = [];
    onBeforeRestartServer = (cleaner) => {
      cleaners.push(cleaner);
    };
    clearConsole = () => {
      if (process.stdout.isTTY && !process.env.DEBUG) {
        process.stdout.write("\x1B[H\x1B[2J");
      }
    };
    restartDevServer = async ({ filePath }) => {
      clearConsole();
      const filename = import_node_path3.default.basename(filePath);
      import_shared4.logger.info(`Restart because ${import_shared4.color.yellow(filename)} is changed.
`);
      for (const cleaner of cleaners) {
        await cleaner();
        cleaners = [];
      }
      const rsbuild = await init({ isRestart: true });
      if (!rsbuild) {
        return;
      }
      await rsbuild.startDevServer();
    };
  }
});

// src/config.ts
function getDefaultEntry(root) {
  const files = [
    // Most projects are using typescript now.
    // So we put `.ts` as the first one to improve performance.
    "ts",
    "js",
    "tsx",
    "jsx",
    "mjs",
    "cjs"
  ].map((ext) => (0, import_node_path4.join)(root, `src/index.${ext}`));
  const entryFile = findExists(files);
  if (entryFile) {
    return {
      index: entryFile
    };
  }
  return {};
}
function defineConfig(config) {
  return config;
}
async function watchFiles(files) {
  if (!files.length) {
    return;
  }
  const chokidar = await import("@rsbuild/shared/chokidar");
  const watcher = chokidar.watch(files, {
    // do not trigger add for initial files
    ignoreInitial: true,
    // If watching fails due to read permissions, the errors will be suppressed silently.
    ignorePermissionErrors: true
  });
  const callback = (0, import_shared5.debounce)(
    async (filePath) => {
      watcher.close();
      await restartDevServer({ filePath });
    },
    // set 300ms debounce to avoid restart frequently
    300
  );
  watcher.on("add", callback);
  watcher.on("change", callback);
  watcher.on("unlink", callback);
}
async function loadConfig({
  cwd = process.cwd(),
  path: path13,
  envMode
} = {}) {
  const configFilePath = resolveConfigPath(cwd, path13);
  if (!configFilePath) {
    return {
      content: {},
      filePath: configFilePath
    };
  }
  const applyMetaInfo = (config) => {
    config._privateMeta = { configFilePath };
    return config;
  };
  try {
    const { default: jiti } = await import("@rsbuild/shared/jiti");
    const loadConfig2 = jiti(__filename, {
      esmResolve: true,
      // disable require cache to support restart CLI and read the new config
      requireCache: false,
      interopDefault: true
    });
    const configExport = loadConfig2(configFilePath);
    if (typeof configExport === "function") {
      const command = process.argv[2];
      const params = {
        env: (0, import_shared5.getNodeEnv)(),
        command,
        envMode: envMode || (0, import_shared5.getNodeEnv)()
      };
      const result = await configExport(params);
      if (result === void 0) {
        throw new Error("Rsbuild config function must return a config object.");
      }
      return {
        content: applyMetaInfo(result),
        filePath: configFilePath
      };
    }
    if (!(0, import_shared5.isObject)(configExport)) {
      throw new Error(
        `Rsbuild config must be an object or a function that returns an object, get ${import_shared5.color.yellow(
          configExport
        )}`
      );
    }
    return {
      content: applyMetaInfo(configExport),
      filePath: configFilePath
    };
  } catch (err) {
    import_shared5.logger.error(`Failed to load file: ${import_shared5.color.dim(configFilePath)}`);
    throw err;
  }
}
async function outputInspectConfigFiles({
  rsbuildConfig,
  rawRsbuildConfig,
  bundlerConfigs,
  inspectOptions,
  configType
}) {
  const { outputPath } = inspectOptions;
  const files = [
    {
      path: (0, import_node_path4.join)(outputPath, "rsbuild.config.mjs"),
      label: "Rsbuild Config",
      content: rawRsbuildConfig
    },
    ...bundlerConfigs.map((content, index) => {
      const suffix = rsbuildConfig.output.targets[index];
      const outputFile = `${configType}.config.${suffix}.mjs`;
      let outputFilePath = (0, import_node_path4.join)(outputPath, outputFile);
      if (import_shared5.fse.existsSync(outputFilePath)) {
        outputFilePath = outputFilePath.replace(/\.mjs$/, `.${Date.now()}.mjs`);
      }
      return {
        path: outputFilePath,
        label: `${(0, import_shared5.upperFirst)(configType)} Config (${suffix})`,
        content
      };
    })
  ];
  await Promise.all(
    files.map(
      (item) => import_shared5.fse.outputFile(item.path, `export default ${item.content}`)
    )
  );
  const fileInfos = files.map(
    (item) => `  - ${import_shared5.color.bold(import_shared5.color.yellow(item.label))}: ${import_shared5.color.underline(
      item.path
    )}`
  ).join("\n");
  import_shared5.logger.success(
    `Inspect config succeed, open following files to view the content: 

${fileInfos}
`
  );
}
async function stringifyConfig(config, verbose) {
  const stringify = import_shared5.RspackChain.toString;
  return stringify(config, { verbose });
}
var import_node_fs, import_node_path4, import_shared5, getDefaultDevConfig, getDefaultServerConfig, getDefaultSourceConfig, getDefaultHtmlConfig, getDefaultSecurityConfig, getDefaultToolsConfig, getDefaultPerformanceConfig, getDefaultOutputConfig, createDefaultConfig, withDefaultConfig, normalizeConfig, resolveConfigPath, normalizePublicDirs;
var init_config = __esm({
  "src/config.ts"() {
    "use strict";
    import_node_fs = __toESM(require("fs"));
    import_node_path4 = require("path");
    import_shared5 = require("@rsbuild/shared");
    init_constants();
    init_helpers();
    init_mergeConfig();
    init_restart();
    getDefaultDevConfig = () => ({
      hmr: true,
      liveReload: true,
      assetPrefix: import_shared5.DEFAULT_ASSET_PREFIX,
      startUrl: false,
      client: {
        overlay: true
      }
    });
    getDefaultServerConfig = () => ({
      port: DEFAULT_PORT,
      host: DEFAULT_DEV_HOST,
      open: false,
      htmlFallback: "index",
      compress: true,
      printUrls: true,
      strictPort: false
    });
    getDefaultSourceConfig = () => ({
      alias: {},
      define: {},
      aliasStrategy: "prefer-tsconfig",
      preEntry: [],
      decorators: {
        version: "legacy"
      }
    });
    getDefaultHtmlConfig = () => ({
      meta: {
        charset: { charset: "UTF-8" },
        viewport: "width=device-width, initial-scale=1.0"
      },
      title: "Rsbuild App",
      inject: "head",
      mountId: DEFAULT_MOUNT_ID,
      crossorigin: false,
      outputStructure: "flat",
      scriptLoading: "defer"
    });
    getDefaultSecurityConfig = () => ({
      nonce: "",
      sri: {
        enable: false
      }
    });
    getDefaultToolsConfig = () => ({
      cssExtract: {
        loaderOptions: {},
        pluginOptions: {
          ignoreOrder: true
        }
      }
    });
    getDefaultPerformanceConfig = () => ({
      profile: false,
      buildCache: true,
      printFileSize: true,
      removeConsole: false,
      removeMomentLocale: false,
      chunkSplit: {
        strategy: "split-by-experience"
      }
    });
    getDefaultOutputConfig = () => ({
      targets: ["web"],
      distPath: {
        root: ROOT_DIST_DIR,
        js: JS_DIST_DIR,
        css: CSS_DIST_DIR,
        svg: SVG_DIST_DIR,
        font: FONT_DIST_DIR,
        html: HTML_DIST_DIR,
        wasm: WASM_DIST_DIR,
        image: IMAGE_DIST_DIR,
        media: MEDIA_DIST_DIR,
        server: SERVER_DIST_DIR,
        worker: SERVICE_WORKER_DIST_DIR
      },
      assetPrefix: import_shared5.DEFAULT_ASSET_PREFIX,
      filename: {},
      charset: "ascii",
      polyfill: "usage",
      dataUriLimit: {
        svg: DEFAULT_DATA_URL_SIZE,
        font: DEFAULT_DATA_URL_SIZE,
        image: DEFAULT_DATA_URL_SIZE,
        media: DEFAULT_DATA_URL_SIZE
      },
      legalComments: "linked",
      injectStyles: false,
      minify: true,
      manifest: false,
      sourceMap: {
        js: void 0,
        css: false
      },
      filenameHash: true,
      inlineScripts: false,
      inlineStyles: false,
      cssModules: {
        auto: true,
        namedExport: false,
        exportGlobals: false,
        exportLocalsConvention: "camelCase"
      },
      emitAssets: () => true
    });
    createDefaultConfig = () => ({
      dev: getDefaultDevConfig(),
      server: getDefaultServerConfig(),
      html: getDefaultHtmlConfig(),
      source: getDefaultSourceConfig(),
      output: getDefaultOutputConfig(),
      tools: getDefaultToolsConfig(),
      security: getDefaultSecurityConfig(),
      performance: getDefaultPerformanceConfig()
    });
    withDefaultConfig = async (rootPath, config) => {
      const merged = mergeRsbuildConfig(createDefaultConfig(), config);
      merged.source ||= {};
      if (!merged.source.entry) {
        merged.source.entry = getDefaultEntry(rootPath);
      }
      if (!merged.source.tsconfigPath) {
        const tsconfigPath = (0, import_node_path4.join)(rootPath, TS_CONFIG_FILE);
        if (await isFileExists(tsconfigPath)) {
          merged.source.tsconfigPath = tsconfigPath;
        }
      }
      return merged;
    };
    normalizeConfig = (config) => mergeRsbuildConfig(createDefaultConfig(), config);
    resolveConfigPath = (root, customConfig) => {
      if (customConfig) {
        const customConfigPath = (0, import_node_path4.isAbsolute)(customConfig) ? customConfig : (0, import_node_path4.join)(root, customConfig);
        if (import_node_fs.default.existsSync(customConfigPath)) {
          return customConfigPath;
        }
        import_shared5.logger.warn(`Cannot find config file: ${import_shared5.color.dim(customConfigPath)}
`);
      }
      const CONFIG_FILES = [
        "rsbuild.config.ts",
        "rsbuild.config.js",
        "rsbuild.config.mjs",
        "rsbuild.config.cjs",
        "rsbuild.config.mts",
        "rsbuild.config.cts"
      ];
      for (const file of CONFIG_FILES) {
        const configFile = (0, import_node_path4.join)(root, file);
        if (import_node_fs.default.existsSync(configFile)) {
          return configFile;
        }
      }
      return null;
    };
    normalizePublicDirs = (publicDir) => {
      if (publicDir === false) {
        return [];
      }
      const defaultConfig = {
        name: "public",
        copyOnBuild: true,
        watch: false
      };
      if (publicDir === void 0) {
        return [defaultConfig];
      }
      if (Array.isArray(publicDir)) {
        return publicDir.map((options) => ({
          ...defaultConfig,
          ...options
        }));
      }
      return [
        {
          ...defaultConfig,
          ...publicDir
        }
      ];
    };
  }
});

// src/loadEnv.ts
function loadEnv({
  cwd = process.cwd(),
  mode = (0, import_shared6.getNodeEnv)(),
  prefixes = ["PUBLIC_"]
} = {}) {
  if (mode === "local") {
    throw new Error(
      `'local' cannot be used as a value for env mode, because ".env.local" represents a temporary local file. Please use another value.`
    );
  }
  const filenames = [
    ".env",
    ".env.local",
    `.env.${mode}`,
    `.env.${mode}.local`
  ];
  const filePaths = filenames.map((filename) => (0, import_node_path5.join)(cwd, filename)).filter(isFileSync);
  const parsed = {};
  for (const envPath of filePaths) {
    Object.assign(parsed, (0, import_dotenv.parse)(import_node_fs2.default.readFileSync(envPath)));
  }
  (0, import_dotenv_expand.expand)({ parsed });
  const publicVars = {};
  for (const key of Object.keys(process.env)) {
    if (prefixes.some((prefix) => key.startsWith(prefix))) {
      const val = process.env[key];
      publicVars[`import.meta.env.${key}`] = JSON.stringify(val);
      publicVars[`process.env.${key}`] = JSON.stringify(val);
    }
  }
  let cleaned = false;
  const cleanup = () => {
    if (cleaned) {
      return;
    }
    for (const key of Object.keys(parsed)) {
      if (key === "NODE_ENV") {
        continue;
      }
      if (process.env[key] === parsed[key]) {
        delete process.env[key];
      }
    }
    cleaned = true;
  };
  return {
    parsed,
    cleanup,
    filePaths,
    publicVars
  };
}
var import_node_fs2, import_node_path5, import_shared6, import_dotenv, import_dotenv_expand;
var init_loadEnv = __esm({
  "src/loadEnv.ts"() {
    "use strict";
    import_node_fs2 = __toESM(require("fs"));
    import_node_path5 = require("path");
    import_shared6 = require("@rsbuild/shared");
    import_dotenv = require("../compiled/dotenv/index.js");
    import_dotenv_expand = require("../compiled/dotenv-expand/index.js");
    init_helpers();
  }
});

// src/initHooks.ts
function createAsyncHook() {
  const preGroup = [];
  const postGroup = [];
  const defaultGroup = [];
  const tap = (cb) => {
    if ((0, import_shared7.isFunction)(cb)) {
      defaultGroup.push(cb);
    } else if (cb.order === "pre") {
      preGroup.push(cb.handler);
    } else if (cb.order === "post") {
      postGroup.push(cb.handler);
    } else {
      defaultGroup.push(cb.handler);
    }
  };
  const call = async (...args) => {
    const params = args.slice(0);
    const callbacks = [...preGroup, ...defaultGroup, ...postGroup];
    for (const callback of callbacks) {
      const result = await callback(...params);
      if (result !== void 0) {
        params[0] = result;
      }
    }
    return params;
  };
  return {
    tap,
    call
  };
}
function initHooks() {
  return {
    onExit: createAsyncHook(),
    onAfterBuild: createAsyncHook(),
    onBeforeBuild: createAsyncHook(),
    onDevCompileDone: createAsyncHook(),
    onCloseDevServer: createAsyncHook(),
    onAfterStartDevServer: createAsyncHook(),
    onBeforeStartDevServer: createAsyncHook(),
    onAfterStartProdServer: createAsyncHook(),
    onBeforeStartProdServer: createAsyncHook(),
    onAfterCreateCompiler: createAsyncHook(),
    onBeforeCreateCompiler: createAsyncHook(),
    modifyHTMLTags: createAsyncHook(),
    modifyRspackConfig: createAsyncHook(),
    modifyBundlerChain: createAsyncHook(),
    modifyWebpackChain: createAsyncHook(),
    modifyWebpackConfig: createAsyncHook(),
    modifyRsbuildConfig: createAsyncHook()
  };
}
var import_shared7;
var init_initHooks = __esm({
  "src/initHooks.ts"() {
    "use strict";
    import_shared7 = require("@rsbuild/shared");
  }
});

// src/plugins/entry.ts
var entry_exports = {};
__export(entry_exports, {
  getEntryObject: () => getEntryObject,
  pluginEntry: () => pluginEntry
});
function getEntryObject(config, target) {
  if (!config.source?.entry) {
    return {};
  }
  return (0, import_shared8.reduceConfigsMergeContext)({
    initial: {},
    config: config.source?.entry,
    ctx: { target }
  });
}
var import_shared8, pluginEntry;
var init_entry = __esm({
  "src/plugins/entry.ts"() {
    "use strict";
    import_shared8 = require("@rsbuild/shared");
    pluginEntry = () => ({
      name: "rsbuild:entry",
      setup(api) {
        api.modifyBundlerChain(
          async (chain, { target, isServer, isServiceWorker }) => {
            const config = api.getNormalizedConfig();
            const { preEntry } = config.source;
            const entry = target === "web" ? api.context.entry : getEntryObject(config, target);
            const injectCoreJsEntry = config.output.polyfill === "entry" && !isServer && !isServiceWorker;
            for (const entryName of Object.keys(entry)) {
              const entryPoint = chain.entry(entryName);
              const addEntry = (item) => {
                entryPoint.add(item);
              };
              preEntry.forEach(addEntry);
              if (injectCoreJsEntry) {
                addEntry((0, import_shared8.createVirtualModule)('import "core-js";'));
              }
              (0, import_shared8.castArray)(entry[entryName]).forEach(addEntry);
            }
          }
        );
        api.onBeforeCreateCompiler(({ bundlerConfigs }) => {
          if (bundlerConfigs.every((config) => !config.entry)) {
            throw new Error(
              `Could not find any entry module, please make sure that ${import_shared8.color.cyan(
                "src/index.(ts|js|tsx|jsx|mjs|cjs)"
              )} exists, or customize entry through the ${import_shared8.color.cyan(
                "source.entry"
              )} configuration.`
            );
          }
        });
      }
    });
  }
});

// src/createContext.ts
function getAbsolutePath(root, filepath) {
  return (0, import_node_path6.isAbsolute)(filepath) ? filepath : (0, import_node_path6.join)(root, filepath);
}
function getAbsoluteDistPath(cwd, config) {
  const dirRoot = (0, import_shared9.getDistPath)(config, "root");
  return getAbsolutePath(cwd, dirRoot);
}
async function createContextByConfig(options, bundlerType, config = {}) {
  const { cwd } = options;
  const rootPath = cwd;
  const distPath = getAbsoluteDistPath(cwd, config);
  const cachePath = (0, import_node_path6.join)(rootPath, "node_modules", ".cache");
  const tsconfigPath = config.source?.tsconfigPath;
  return {
    entry: getEntryObject(config, "web"),
    targets: config.output?.targets || [],
    version: "0.7.7",
    rootPath,
    distPath,
    cachePath,
    bundlerType,
    tsconfigPath: tsconfigPath ? getAbsolutePath(rootPath, tsconfigPath) : void 0
  };
}
function updateContextByNormalizedConfig(context, config) {
  context.targets = config.output.targets;
  context.distPath = getAbsoluteDistPath(context.rootPath, config);
  if (config.source.entry) {
    context.entry = getEntryObject(config, "web");
  }
  if (config.source.tsconfigPath) {
    context.tsconfigPath = getAbsolutePath(
      context.rootPath,
      config.source.tsconfigPath
    );
  }
}
function createPublicContext(context) {
  const exposedKeys = [
    "entry",
    "targets",
    "version",
    "rootPath",
    "distPath",
    "devServer",
    "cachePath",
    "configPath",
    "tsconfigPath",
    "bundlerType"
  ];
  return new Proxy(context, {
    get(target, prop) {
      if (exposedKeys.includes(prop)) {
        return target[prop];
      }
      return void 0;
    },
    set(_, prop) {
      import_shared9.logger.error(
        `Context is readonly, you can not assign to the "context.${prop}" prop.`
      );
      return true;
    }
  });
}
async function createContext(options, userRsbuildConfig, bundlerType) {
  const rsbuildConfig = await withDefaultConfig(options.cwd, userRsbuildConfig);
  const context = await createContextByConfig(
    options,
    bundlerType,
    rsbuildConfig
  );
  return {
    ...context,
    hooks: initHooks(),
    config: { ...rsbuildConfig },
    originalConfig: userRsbuildConfig
  };
}
var import_node_path6, import_shared9;
var init_createContext = __esm({
  "src/createContext.ts"() {
    "use strict";
    import_node_path6 = require("path");
    import_shared9 = require("@rsbuild/shared");
    init_config();
    init_initHooks();
    init_entry();
  }
});

// src/initPlugins.ts
function getHTMLPathByEntry(entryName, config) {
  const htmlPath = (0, import_shared10.getDistPath)(config, "html");
  const filename = config.html.outputStructure === "flat" ? `${entryName}.html` : `${entryName}/index.html`;
  return (0, import_shared10.removeLeadingSlash)(`${htmlPath}/${filename}`);
}
function applyTransformPlugin(chain, transformer) {
  const name = "RsbuildTransformPlugin";
  if (chain.plugins.get(name)) {
    return;
  }
  class RsbuildTransformPlugin {
    apply(compiler) {
      compiler.__rsbuildTransformer = transformer;
      compiler.hooks.thisCompilation.tap(name, (compilation) => {
        compilation.hooks.childCompiler.tap(name, (childCompiler) => {
          childCompiler.__rsbuildTransformer = transformer;
        });
      });
    }
  }
  chain.plugin(name).use(RsbuildTransformPlugin);
}
function getPluginAPI({
  context,
  pluginManager
}) {
  const { hooks } = context;
  const publicContext = createPublicContext(context);
  const getNormalizedConfig = () => {
    if (context.normalizedConfig) {
      return context.normalizedConfig;
    }
    throw new Error(
      "Cannot access normalized config until modifyRsbuildConfig is called."
    );
  };
  const getRsbuildConfig = (type = "current") => {
    switch (type) {
      case "original":
        return context.originalConfig;
      case "current":
        return context.config;
      case "normalized":
        return getNormalizedConfig();
    }
    throw new Error("`getRsbuildConfig` get an invalid type param.");
  };
  const getHTMLPaths = () => {
    return Object.keys(context.entry).reduce(
      (prev, key) => {
        prev[key] = getHTMLPathByEntry(key, getNormalizedConfig());
        return prev;
      },
      {}
    );
  };
  const exposed = [];
  const expose = (id, api) => {
    exposed.push({ id, api });
  };
  const useExposed = (id) => {
    const matched = exposed.find((item) => item.id === id);
    if (matched) {
      return matched.api;
    }
  };
  let transformId = 0;
  const transformer = {};
  const transform = (descriptor, handler) => {
    const id = `rsbuild-transform-${transformId++}`;
    transformer[id] = handler;
    hooks.modifyBundlerChain.tap((chain, { target }) => {
      if (descriptor.targets && !descriptor.targets.includes(target)) {
        return;
      }
      const rule = chain.module.rule(id);
      if (descriptor.test) {
        rule.test(descriptor.test);
      }
      if (descriptor.resourceQuery) {
        rule.resourceQuery(descriptor.resourceQuery);
      }
      const loaderName = descriptor.raw ? "transformRawLoader.cjs" : "transformLoader.cjs";
      const loaderPath = (0, import_node_path7.join)(LOADER_PATH, loaderName);
      rule.use(id).loader(loaderPath).options({ id });
      applyTransformPlugin(chain, transformer);
    });
  };
  process.on("exit", () => {
    hooks.onExit.call();
  });
  return {
    context: publicContext,
    expose,
    transform,
    useExposed,
    getHTMLPaths,
    getRsbuildConfig,
    getNormalizedConfig,
    isPluginExists: pluginManager.isPluginExists,
    // Hooks
    onExit: hooks.onExit.tap,
    onAfterBuild: hooks.onAfterBuild.tap,
    onBeforeBuild: hooks.onBeforeBuild.tap,
    onCloseDevServer: hooks.onCloseDevServer.tap,
    onDevCompileDone: hooks.onDevCompileDone.tap,
    onAfterCreateCompiler: hooks.onAfterCreateCompiler.tap,
    onAfterStartDevServer: hooks.onAfterStartDevServer.tap,
    onBeforeCreateCompiler: hooks.onBeforeCreateCompiler.tap,
    onBeforeStartDevServer: hooks.onBeforeStartDevServer.tap,
    onAfterStartProdServer: hooks.onAfterStartProdServer.tap,
    onBeforeStartProdServer: hooks.onBeforeStartProdServer.tap,
    modifyHTMLTags: hooks.modifyHTMLTags.tap,
    modifyBundlerChain: hooks.modifyBundlerChain.tap,
    modifyRspackConfig: hooks.modifyRspackConfig.tap,
    modifyWebpackChain: hooks.modifyWebpackChain.tap,
    modifyWebpackConfig: hooks.modifyWebpackConfig.tap,
    modifyRsbuildConfig: hooks.modifyRsbuildConfig.tap
  };
}
var import_node_path7, import_shared10;
var init_initPlugins = __esm({
  "src/initPlugins.ts"() {
    "use strict";
    import_node_path7 = require("path");
    import_shared10 = require("@rsbuild/shared");
    init_constants();
    init_createContext();
  }
});

// src/pluginHelper.ts
var import_core, htmlPlugin, setHTMLPlugin, getHTMLPlugin, cssExtractPlugin, setCssExtractPlugin, getCssExtractPlugin;
var init_pluginHelper = __esm({
  "src/pluginHelper.ts"() {
    "use strict";
    import_core = __toESM(require("@rspack/core"));
    setHTMLPlugin = (plugin) => {
      if (plugin) {
        htmlPlugin = plugin;
      }
    };
    getHTMLPlugin = () => {
      if (!htmlPlugin) {
        htmlPlugin = require("html-webpack-plugin");
      }
      return htmlPlugin;
    };
    setCssExtractPlugin = (plugin) => {
      cssExtractPlugin = plugin;
    };
    getCssExtractPlugin = () => {
      if (cssExtractPlugin) {
        return cssExtractPlugin;
      }
      return import_core.default.CssExtractRspackPlugin;
    };
  }
});

// src/pluginManager.ts
function validatePlugin(plugin) {
  const type = typeof plugin;
  if (type !== "object" || plugin === null) {
    throw new Error(
      `Expect Rsbuild plugin instance to be an object, but got ${type}.`
    );
  }
  if ((0, import_shared11.isFunction)(plugin.setup)) {
    return;
  }
  if ((0, import_shared11.isFunction)(plugin.apply)) {
    const { name = "SomeWebpackPlugin" } = plugin.constructor || {};
    const messages = [
      `${import_shared11.color.yellow(
        name
      )} looks like a Webpack or Rspack plugin, please use ${import_shared11.color.yellow(
        "`tools.rspack`"
      )} to register it:`,
      import_shared11.color.green(`
  // rsbuild.config.ts
  export default {
    tools: {
      rspack: {
        plugins: [new ${name}()]
      }
    }
  };
`)
    ];
    throw new Error(messages.join("\n"));
  }
  throw new Error(
    `Expect Rsbuild plugin.setup to be a function, but got ${type}.`
  );
}
function createPluginManager() {
  let plugins = [];
  const addPlugins = (newPlugins, options) => {
    const { before } = options || {};
    for (const newPlugin of newPlugins) {
      if (!newPlugin) {
        continue;
      }
      validatePlugin(newPlugin);
      if (plugins.find((item) => item.name === newPlugin.name)) {
        import_shared11.logger.warn(
          `Rsbuild plugin "${newPlugin.name}" registered multiple times.`
        );
      } else if (before) {
        const index = plugins.findIndex((item) => item.name === before);
        if (index === -1) {
          import_shared11.logger.warn(`Plugin "${before}" does not exist.`);
          plugins.push(newPlugin);
        } else {
          plugins.splice(index, 0, newPlugin);
        }
      } else {
        plugins.push(newPlugin);
      }
    }
  };
  const removePlugins = (pluginNames) => {
    plugins = plugins.filter((plugin) => !pluginNames.includes(plugin.name));
  };
  const isPluginExists = (pluginName) => Boolean(plugins.find((plugin) => plugin.name === pluginName));
  return {
    getPlugins: () => plugins,
    addPlugins,
    removePlugins,
    isPluginExists
  };
}
async function initPlugins({
  pluginAPI,
  pluginManager
}) {
  (0, import_shared11.debug)("init plugins");
  const plugins = pluginDagSort(pluginManager.getPlugins());
  const removedPlugins = plugins.reduce((ret, plugin) => {
    if (plugin.remove) {
      return ret.concat(plugin.remove);
    }
    return ret;
  }, []);
  for (const plugin of plugins) {
    if (removedPlugins.includes(plugin.name)) {
      continue;
    }
    await plugin.setup(pluginAPI);
  }
  (0, import_shared11.debug)("init plugins done");
}
var import_shared11, pluginDagSort;
var init_pluginManager = __esm({
  "src/pluginManager.ts"() {
    "use strict";
    import_shared11 = require("@rsbuild/shared");
    pluginDagSort = (plugins) => {
      let allLines = [];
      function getPlugin(name) {
        const target = plugins.find((item) => item.name === name);
        if (!target) {
          throw new Error(`plugin ${name} not existed`);
        }
        return target;
      }
      for (const plugin of plugins) {
        if (plugin.pre) {
          for (const pre of plugin.pre) {
            if (pre && plugins.some((item) => item.name === pre)) {
              allLines.push([pre, plugin.name]);
            }
          }
        }
        if (plugin.post) {
          for (const post of plugin.post) {
            if (post && plugins.some((item) => item.name === post)) {
              allLines.push([plugin.name, post]);
            }
          }
        }
      }
      let zeroEndPoints = plugins.filter(
        (item) => !allLines.find((l) => l[1] === item.name)
      );
      const sortedPoint = [];
      while (zeroEndPoints.length) {
        const zep = zeroEndPoints.shift();
        sortedPoint.push(getPlugin(zep.name));
        allLines = allLines.filter((l) => l[0] !== getPlugin(zep.name).name);
        const restPoints = plugins.filter(
          (item) => !sortedPoint.find((sp) => sp.name === item.name)
        );
        zeroEndPoints = restPoints.filter(
          (item) => !allLines.find((l) => l[1] === item.name)
        );
      }
      if (allLines.length) {
        const restInRingPoints = {};
        for (const l of allLines) {
          restInRingPoints[l[0]] = true;
          restInRingPoints[l[1]] = true;
        }
        throw new Error(
          `plugins dependencies has loop: ${Object.keys(restInRingPoints).join(
            ","
          )}`
        );
      }
      return sortedPoint;
    };
  }
});

// src/provider/inspectConfig.ts
var inspectConfig_exports = {};
__export(inspectConfig_exports, {
  inspectConfig: () => inspectConfig
});
async function inspectConfig({
  context,
  pluginManager,
  rsbuildOptions,
  bundlerConfigs,
  inspectOptions = {}
}) {
  if (inspectOptions.env) {
    (0, import_shared12.setNodeEnv)(inspectOptions.env);
  } else if (!(0, import_shared12.getNodeEnv)()) {
    (0, import_shared12.setNodeEnv)("development");
  }
  const rspackConfigs = bundlerConfigs || (await initConfigs({
    context,
    pluginManager,
    rsbuildOptions
  })).rspackConfigs;
  const rsbuildDebugConfig = {
    ...context.normalizedConfig,
    pluginNames: pluginManager.getPlugins().map((p) => p.name)
  };
  const rawRsbuildConfig = await stringifyConfig(
    rsbuildDebugConfig,
    inspectOptions.verbose
  );
  const rawBundlerConfigs = await Promise.all(
    rspackConfigs.map(
      (config) => stringifyConfig(config, inspectOptions.verbose)
    )
  );
  let outputPath = inspectOptions.outputPath || context.distPath;
  if (!(0, import_node_path8.isAbsolute)(outputPath)) {
    outputPath = (0, import_node_path8.join)(context.rootPath, outputPath);
  }
  if (inspectOptions.writeToDisk) {
    await outputInspectConfigFiles({
      rsbuildConfig: context.normalizedConfig,
      rawRsbuildConfig,
      bundlerConfigs: rawBundlerConfigs,
      inspectOptions: {
        ...inspectOptions,
        outputPath
      },
      configType: "rspack"
    });
  }
  return {
    rsbuildConfig: rawRsbuildConfig,
    bundlerConfigs: rawBundlerConfigs,
    origin: {
      rsbuildConfig: rsbuildDebugConfig,
      bundlerConfigs: rspackConfigs
    }
  };
}
var import_node_path8, import_shared12;
var init_inspectConfig = __esm({
  "src/provider/inspectConfig.ts"() {
    "use strict";
    import_node_path8 = require("path");
    import_shared12 = require("@rsbuild/shared");
    init_config();
    init_initConfigs();
  }
});

// src/provider/rspackConfig.ts
async function modifyRspackConfig(context, rspackConfig, utils) {
  (0, import_shared13.debug)("modify Rspack config");
  let [modifiedConfig] = await context.hooks.modifyRspackConfig.call(
    rspackConfig,
    utils
  );
  if (context.config.tools?.rspack) {
    modifiedConfig = await (0, import_shared13.reduceConfigsAsyncWithContext)({
      initial: modifiedConfig,
      config: context.config.tools.rspack,
      ctx: utils,
      mergeFn: utils.mergeConfig
    });
  }
  (0, import_shared13.debug)("modify Rspack config done");
  return modifiedConfig;
}
async function getConfigUtils(config, chainUtils) {
  const { merge: merge2 } = await import("@rsbuild/shared/webpack-merge");
  return {
    ...chainUtils,
    rspack: import_core2.rspack,
    mergeConfig: merge2,
    addRules(rules) {
      const ruleArr = (0, import_shared13.castArray)(rules);
      if (!config.module) {
        config.module = {};
      }
      if (!config.module.rules) {
        config.module.rules = [];
      }
      config.module.rules.unshift(...ruleArr);
    },
    prependPlugins(plugins) {
      const pluginArr = (0, import_shared13.castArray)(plugins);
      if (!config.plugins) {
        config.plugins = [];
      }
      config.plugins.unshift(...pluginArr);
    },
    appendPlugins(plugins) {
      const pluginArr = (0, import_shared13.castArray)(plugins);
      if (!config.plugins) {
        config.plugins = [];
      }
      config.plugins.push(...pluginArr);
    },
    removePlugin(pluginName) {
      if (config.plugins) {
        config.plugins = config.plugins.filter(
          (p) => p && p.name !== pluginName
        );
      }
    }
  };
}
function getChainUtils(target) {
  const nodeEnv = (0, import_shared13.getNodeEnv)();
  return {
    env: nodeEnv,
    target,
    isDev: nodeEnv === "development",
    isProd: nodeEnv === "production",
    isServer: target === "node",
    isWebWorker: target === "web-worker",
    isServiceWorker: target === "service-worker",
    CHAIN_ID: import_shared13.CHAIN_ID,
    HtmlPlugin: getHTMLPlugin()
  };
}
async function generateRspackConfig({
  target,
  context
}) {
  const chainUtils = getChainUtils(target);
  const {
    BannerPlugin,
    DefinePlugin,
    IgnorePlugin,
    ProvidePlugin,
    HotModuleReplacementPlugin
  } = import_core2.rspack;
  const chain = await (0, import_shared13.modifyBundlerChain)(context, {
    ...chainUtils,
    bundler: {
      BannerPlugin,
      DefinePlugin,
      IgnorePlugin,
      ProvidePlugin,
      HotModuleReplacementPlugin
    }
  });
  let rspackConfig = (0, import_shared13.chainToConfig)(chain);
  rspackConfig = await modifyRspackConfig(
    context,
    rspackConfig,
    await getConfigUtils(rspackConfig, chainUtils)
  );
  return rspackConfig;
}
var import_shared13, import_core2;
var init_rspackConfig = __esm({
  "src/provider/rspackConfig.ts"() {
    "use strict";
    import_shared13 = require("@rsbuild/shared");
    import_core2 = require("@rspack/core");
    init_pluginHelper();
  }
});

// src/provider/initConfigs.ts
async function modifyRsbuildConfig(context) {
  (0, import_shared14.debug)("modify Rsbuild config");
  const [modified] = await context.hooks.modifyRsbuildConfig.call(
    context.config,
    { mergeRsbuildConfig }
  );
  context.config = modified;
  (0, import_shared14.debug)("modify Rsbuild config done");
}
async function initRsbuildConfig({
  context,
  pluginManager
}) {
  if (context.normalizedConfig) {
    return context.normalizedConfig;
  }
  await initPlugins({
    pluginAPI: context.pluginAPI,
    pluginManager
  });
  await modifyRsbuildConfig(context);
  context.normalizedConfig = normalizeConfig(context.config);
  updateContextByNormalizedConfig(context, context.normalizedConfig);
  return context.normalizedConfig;
}
async function initConfigs({
  context,
  pluginManager,
  rsbuildOptions
}) {
  const normalizedConfig = await initRsbuildConfig({ context, pluginManager });
  const { targets } = normalizedConfig.output;
  const rspackConfigs = await Promise.all(
    targets.map((target) => generateRspackConfig({ target, context }))
  );
  if ((0, import_shared14.isDebug)()) {
    const inspect = () => {
      const inspectOptions = {
        verbose: true,
        writeToDisk: true
      };
      inspectConfig({
        context,
        pluginManager,
        inspectOptions,
        rsbuildOptions,
        bundlerConfigs: rspackConfigs
      });
    };
    context.hooks.onBeforeBuild.tap(inspect);
    context.hooks.onAfterStartDevServer.tap(inspect);
  }
  return {
    rspackConfigs
  };
}
var import_shared14;
var init_initConfigs = __esm({
  "src/provider/initConfigs.ts"() {
    "use strict";
    import_shared14 = require("@rsbuild/shared");
    init_config();
    init_createContext();
    init_mergeConfig();
    init_pluginManager();
    init_inspectConfig();
    init_rspackConfig();
  }
});

// src/server/devMiddleware.ts
var devMiddleware_exports = {};
__export(devMiddleware_exports, {
  getDevMiddleware: () => getDevMiddleware,
  setupServerHooks: () => setupServerHooks
});
function applyHMREntry({
  compiler,
  clientPaths,
  clientConfig = {},
  liveReload = true
}) {
  if (!(0, import_shared15.isClientCompiler)(compiler)) {
    return;
  }
  new compiler.webpack.DefinePlugin({
    RSBUILD_CLIENT_CONFIG: JSON.stringify(clientConfig),
    RSBUILD_DEV_LIVE_RELOAD: liveReload
  }).apply(compiler);
  for (const clientPath of clientPaths) {
    new compiler.webpack.EntryPlugin(compiler.context, clientPath, {
      name: void 0
    }).apply(compiler);
  }
}
var import_shared15, setupServerHooks, getDevMiddleware;
var init_devMiddleware = __esm({
  "src/server/devMiddleware.ts"() {
    "use strict";
    import_shared15 = require("@rsbuild/shared");
    setupServerHooks = (compiler, hookCallbacks) => {
      if ((0, import_shared15.isNodeCompiler)(compiler)) {
        return;
      }
      const { compile, invalid, done } = compiler.hooks;
      compile.tap("rsbuild-dev-server", hookCallbacks.onInvalid);
      invalid.tap("rsbuild-dev-server", hookCallbacks.onInvalid);
      done.tap("rsbuild-dev-server", hookCallbacks.onDone);
    };
    getDevMiddleware = async (multiCompiler) => {
      const { default: webpackDevMiddleware } = await import("../compiled/webpack-dev-middleware/index.js");
      return (options) => {
        const { clientPaths, clientConfig, callbacks, liveReload, ...restOptions } = options;
        const setupCompiler = (compiler) => {
          if (clientPaths) {
            applyHMREntry({
              compiler,
              clientPaths,
              clientConfig,
              liveReload
            });
          }
          setupServerHooks(compiler, callbacks);
        };
        (0, import_shared15.applyToCompiler)(multiCompiler, setupCompiler);
        return webpackDevMiddleware(multiCompiler, restOptions);
      };
    };
  }
});

// src/provider/createCompiler.ts
var createCompiler_exports = {};
__export(createCompiler_exports, {
  createCompiler: () => createCompiler,
  createDevMiddleware: () => createDevMiddleware
});
async function createCompiler({
  context,
  rspackConfigs
}) {
  (0, import_shared16.debug)("create compiler");
  await context.hooks.onBeforeCreateCompiler.call({
    bundlerConfigs: rspackConfigs
  });
  if (!await isSatisfyRspackVersion(import_core3.rspack.rspackVersion)) {
    throw new Error(
      `The current Rspack version does not meet the requirements, the minimum supported version of Rspack is ${import_shared16.color.green(
        rspackMinVersion
      )}`
    );
  }
  const compiler = rspackConfigs.length === 1 ? (0, import_core3.rspack)(rspackConfigs[0]) : (0, import_core3.rspack)(rspackConfigs);
  let isFirstCompile = true;
  let isVersionLogged = false;
  let isCompiling = false;
  const logRspackVersion = () => {
    if (!isVersionLogged) {
      (0, import_shared16.debug)(`Use Rspack v${import_core3.rspack.rspackVersion}`);
      isVersionLogged = true;
    }
  };
  compiler.hooks.watchRun.tap("rsbuild:compiling", () => {
    logRspackVersion();
    if (!isCompiling) {
      import_shared16.logger.start("Compiling...");
    }
    isCompiling = true;
  });
  if ((0, import_shared16.isProd)()) {
    compiler.hooks.run.tap("rsbuild:run", logRspackVersion);
  }
  const done = async (stats) => {
    const obj = stats.toJson({
      all: false,
      timings: true
    });
    const printTime = (c, index) => {
      if (c.time) {
        const time = (0, import_shared16.prettyTime)(c.time / 1e3);
        const target = context.targets[index];
        const name = import_shared16.TARGET_ID_MAP[target || "web"];
        import_shared16.logger.ready(`${name} compiled in ${time}`);
      }
    };
    if (!stats.hasErrors()) {
      if (obj.children) {
        obj.children.forEach((c, index) => {
          printTime(c, index);
        });
      } else {
        printTime(obj, 0);
      }
    }
    const { message, level } = formatStats(stats, getStatsOptions(compiler));
    if (level === "error") {
      import_shared16.logger.error(message);
    }
    if (level === "warning") {
      import_shared16.logger.warn(message);
    }
    if ((0, import_shared16.isDev)()) {
      await context.hooks.onDevCompileDone.call({
        isFirstCompile,
        stats
      });
    }
    isCompiling = false;
    isFirstCompile = false;
  };
  (0, import_shared16.onCompileDone)(
    compiler,
    done,
    // @ts-expect-error type mismatch
    import_core3.rspack.MultiStats
  );
  await context.hooks.onAfterCreateCompiler.call({ compiler });
  (0, import_shared16.debug)("create compiler done");
  return compiler;
}
async function createDevMiddleware(options, customCompiler) {
  let compiler;
  if (customCompiler) {
    compiler = customCompiler;
  } else {
    const { rspackConfigs } = await initConfigs(options);
    compiler = await createCompiler({
      context: options.context,
      rspackConfigs
    });
  }
  const { getDevMiddleware: getDevMiddleware2 } = await Promise.resolve().then(() => (init_devMiddleware(), devMiddleware_exports));
  return {
    devMiddleware: await getDevMiddleware2(compiler),
    compiler
  };
}
var import_shared16, import_core3;
var init_createCompiler = __esm({
  "src/provider/createCompiler.ts"() {
    "use strict";
    import_shared16 = require("@rsbuild/shared");
    import_core3 = require("@rspack/core");
    init_helpers();
    init_initConfigs();
  }
});

// src/server/middlewares.ts
var import_node_path9, import_node_url, import_shared17, faviconFallbackMiddleware, getStatusCodeColor, getRequestLoggerMiddleware, notFoundMiddleware, getHtmlFallbackMiddleware;
var init_middlewares = __esm({
  "src/server/middlewares.ts"() {
    "use strict";
    import_node_path9 = __toESM(require("path"));
    import_node_url = require("url");
    import_shared17 = require("@rsbuild/shared");
    faviconFallbackMiddleware = (req, res, next) => {
      if (req.url === "/favicon.ico") {
        res.statusCode = 204;
        res.end();
      } else {
        next();
      }
    };
    getStatusCodeColor = (status) => {
      if (status >= 500) {
        return import_shared17.color.red;
      }
      if (status >= 400) {
        return import_shared17.color.yellow;
      }
      if (status >= 300) {
        return import_shared17.color.cyan;
      }
      if (status >= 200) {
        return import_shared17.color.green;
      }
      return (res) => res;
    };
    getRequestLoggerMiddleware = async () => {
      const { default: onFinished } = await import("../compiled/on-finished/index.js");
      return (req, res, next) => {
        const _startAt = process.hrtime();
        const logRequest = () => {
          const method = req.method;
          const url2 = req.originalUrl || req.url;
          const status = Number(res.statusCode);
          const statusColor = getStatusCodeColor(status);
          const endAt = process.hrtime();
          const totalTime = (endAt[0] - _startAt[0]) * 1e3 + (endAt[1] - _startAt[1]) * 1e-6;
          (0, import_shared17.debug)(
            `${statusColor(status)} ${method} ${import_shared17.color.gray(url2)} ${import_shared17.color.gray(
              `${totalTime.toFixed(3)} ms`
            )}`
          );
        };
        onFinished(res, logRequest);
        next();
      };
    };
    notFoundMiddleware = (_req, res, _next) => {
      res.statusCode = 404;
      res.end();
    };
    getHtmlFallbackMiddleware = ({ htmlFallback, distPath, callback, outputFileSystem }) => {
      return async (req, res, next) => {
        if (
          // Only accept GET or HEAD
          req.method !== "GET" && req.method !== "HEAD" || // Require Accept header
          !req.headers || typeof req.headers.accept !== "string" || // Ignore JSON requests
          req.headers.accept.includes("application/json") || // Require Accept: text/html or */*
          !(req.headers.accept.includes("text/html") || req.headers.accept.includes("*/*")) || !req.url || ["/favicon.ico"].includes(req.url)
        ) {
          return next();
        }
        const { url: url2 } = req;
        let pathname = url2;
        try {
          pathname = (0, import_node_url.parse)(url2, false, true).pathname;
        } catch (err) {
          import_shared17.logger.error(
            new Error(`Invalid URL: ${import_shared17.color.yellow(url2)}`, { cause: err })
          );
          return next();
        }
        const isFileExists2 = async (filePath) => {
          return new Promise((resolve) => {
            outputFileSystem.stat(filePath, (_error, stats) => {
              resolve(stats?.isFile());
            });
          });
        };
        const rewrite = (newUrl, isFallback = false) => {
          if (isFallback && (0, import_shared17.isDebug)()) {
            (0, import_shared17.debug)(
              `${req.method} ${import_shared17.color.gray(
                `${req.url} ${import_shared17.color.yellow("fallback")} to ${newUrl}`
              )}`
            );
          }
          req.url = newUrl;
          if (callback) {
            return callback(req, res, (...args) => {
              next(...args);
            });
          }
          return next();
        };
        if (pathname.endsWith("/")) {
          const newUrl = `${pathname}index.html`;
          const filePath = import_node_path9.default.join(distPath, pathname, "index.html");
          if (await isFileExists2(filePath)) {
            return rewrite(newUrl);
          }
        } else if (
          // '/main' => '/main.html'
          !pathname.endsWith(".html")
        ) {
          const newUrl = `${pathname}.html`;
          const filePath = import_node_path9.default.join(distPath, `${pathname}.html`);
          if (await isFileExists2(filePath)) {
            return rewrite(newUrl);
          }
        }
        if (htmlFallback === "index") {
          if (await isFileExists2(import_node_path9.default.join(distPath, "index.html"))) {
            return rewrite("/index.html", true);
          }
        }
        next();
      };
    };
  }
});

// src/server/proxy.ts
var proxy_exports = {};
__export(proxy_exports, {
  createProxyMiddleware: () => createProxyMiddleware,
  formatProxyOptions: () => formatProxyOptions
});
function formatProxyOptions(proxyOptions) {
  const ret = [];
  if (Array.isArray(proxyOptions)) {
    ret.push(...proxyOptions);
  } else if ("target" in proxyOptions) {
    ret.push(proxyOptions);
  } else {
    for (const [context, options] of Object.entries(proxyOptions)) {
      const opts = {
        context,
        changeOrigin: true,
        logLevel: "warn"
      };
      if (typeof options === "string") {
        opts.target = options;
      } else {
        Object.assign(opts, options);
      }
      ret.push(opts);
    }
  }
  const handleError = (err) => import_shared18.logger.error(err);
  for (const opts of ret) {
    opts.onError ??= handleError;
  }
  return ret;
}
var import_shared18, import_http_proxy_middleware, createProxyMiddleware;
var init_proxy = __esm({
  "src/server/proxy.ts"() {
    "use strict";
    import_shared18 = require("@rsbuild/shared");
    import_http_proxy_middleware = require("@rsbuild/shared/http-proxy-middleware");
    createProxyMiddleware = (proxyOptions) => {
      const formattedOptionsList = formatProxyOptions(proxyOptions);
      const proxyMiddlewares = [];
      const middlewares = [];
      for (const opts of formattedOptionsList) {
        const proxyMiddleware = (0, import_http_proxy_middleware.createProxyMiddleware)(opts.context, opts);
        const middleware = async (req, res, next) => {
          const bypassUrl = typeof opts.bypass === "function" ? opts.bypass(req, res, opts) : null;
          if (bypassUrl === false) {
            res.statusCode = 404;
            next();
          } else if (typeof bypassUrl === "string") {
            req.url = bypassUrl;
            next();
          } else if (bypassUrl === true) {
            next();
          } else {
            proxyMiddleware(req, res, next);
          }
        };
        middlewares.push(middleware);
        opts.ws && proxyMiddlewares.push(proxyMiddleware);
      }
      const handleUpgrade = (req, socket, head) => {
        for (const middleware of proxyMiddlewares) {
          if (typeof middleware.upgrade === "function") {
            middleware.upgrade(req, socket, head);
          }
        }
      };
      return {
        middlewares,
        upgrade: handleUpgrade
      };
    };
  }
});

// src/server/getDevMiddlewares.ts
var import_node_path10, import_node_url2, import_shared19, applySetupMiddlewares, applyDefaultMiddlewares, getMiddlewares;
var init_getDevMiddlewares = __esm({
  "src/server/getDevMiddlewares.ts"() {
    "use strict";
    import_node_path10 = require("path");
    import_node_url2 = __toESM(require("url"));
    import_shared19 = require("@rsbuild/shared");
    init_config();
    init_middlewares();
    applySetupMiddlewares = (dev, compileMiddlewareAPI) => {
      const setupMiddlewares = dev.setupMiddlewares || [];
      const serverOptions = {
        sockWrite: (type, data) => compileMiddlewareAPI?.sockWrite(type, data)
      };
      const before = [];
      const after = [];
      for (const handler of setupMiddlewares) {
        handler(
          {
            unshift: (...handlers) => before.unshift(...handlers),
            push: (...handlers) => after.push(...handlers)
          },
          serverOptions
        );
      }
      return { before, after };
    };
    applyDefaultMiddlewares = async ({
      middlewares,
      server,
      compileMiddlewareAPI,
      output,
      pwd,
      outputFileSystem
    }) => {
      const upgradeEvents = [];
      if (server.compress) {
        const { default: compression } = await import("../compiled/http-compression/index.js");
        middlewares.push((req, res, next) => {
          compression({
            gzip: true,
            brotli: false
          })(req, res, next);
        });
      }
      middlewares.push((req, res, next) => {
        res.setHeader("Access-Control-Allow-Origin", "*");
        const path13 = req.url ? import_node_url2.default.parse(req.url).pathname : "";
        if (path13?.includes("hot-update")) {
          res.setHeader("Access-Control-Allow-Credentials", "false");
        }
        const confHeaders = server.headers;
        if (confHeaders) {
          for (const [key, value] of Object.entries(confHeaders)) {
            res.setHeader(key, value);
          }
        }
        next();
      });
      if (server.proxy) {
        const { createProxyMiddleware: createProxyMiddleware2 } = await Promise.resolve().then(() => (init_proxy(), proxy_exports));
        const { middlewares: proxyMiddlewares, upgrade } = createProxyMiddleware2(
          server.proxy
        );
        upgradeEvents.push(upgrade);
        for (const middleware of proxyMiddlewares) {
          middlewares.push(middleware);
        }
      }
      const { default: launchEditorMiddleware } = await import("../compiled/launch-editor-middleware/index.js");
      middlewares.push(["/__open-in-editor", launchEditorMiddleware()]);
      if (compileMiddlewareAPI) {
        middlewares.push(compileMiddlewareAPI.middleware);
        upgradeEvents.push(
          compileMiddlewareAPI.onUpgrade.bind(compileMiddlewareAPI)
        );
        middlewares.push((req, res, next) => {
          if (req.url?.endsWith(".hot-update.json")) {
            res.statusCode = 404;
            res.end();
          } else {
            next();
          }
        });
      }
      const publicDirs = normalizePublicDirs(server?.publicDir);
      for (const publicDir of publicDirs) {
        const { default: sirv } = await import("../compiled/sirv/index.js");
        const { name } = publicDir;
        const normalizedPath = (0, import_node_path10.isAbsolute)(name) ? name : (0, import_node_path10.join)(pwd, name);
        const assetMiddleware = sirv(normalizedPath, {
          etag: true,
          dev: true
        });
        middlewares.push(assetMiddleware);
      }
      const { distPath } = output;
      compileMiddlewareAPI && middlewares.push(
        getHtmlFallbackMiddleware({
          distPath: (0, import_node_path10.isAbsolute)(distPath) ? distPath : (0, import_node_path10.join)(pwd, distPath),
          callback: compileMiddlewareAPI.middleware,
          htmlFallback: server.htmlFallback,
          outputFileSystem
        })
      );
      if (server.historyApiFallback) {
        const { default: connectHistoryApiFallback } = await import("../compiled/connect-history-api-fallback/index.js");
        const historyApiFallbackMiddleware = connectHistoryApiFallback(
          server.historyApiFallback === true ? {} : server.historyApiFallback
        );
        middlewares.push(historyApiFallbackMiddleware);
        compileMiddlewareAPI?.middleware && middlewares.push(compileMiddlewareAPI.middleware);
      }
      middlewares.push(faviconFallbackMiddleware);
      return {
        onUpgrade: (...args) => {
          for (const cb of upgradeEvents) {
            cb(...args);
          }
        }
      };
    };
    getMiddlewares = async (options) => {
      const middlewares = [];
      const { compileMiddlewareAPI } = options;
      if ((0, import_shared19.isDebug)()) {
        middlewares.push(await getRequestLoggerMiddleware());
      }
      const { before, after } = applySetupMiddlewares(
        options.dev,
        compileMiddlewareAPI
      );
      middlewares.push(...before);
      const { onUpgrade } = await applyDefaultMiddlewares({
        ...options,
        middlewares
      });
      middlewares.push(...after);
      return {
        close: async () => {
          compileMiddlewareAPI?.close();
        },
        onUpgrade,
        middlewares
      };
    };
  }
});

// src/server/helper.ts
function getURLMessages(urls, routes) {
  if (routes.length === 1) {
    return urls.map(
      ({ label, url: url2 }) => `  ${`> ${label.padEnd(10)}`}${import_shared20.color.cyan(
        (0, import_shared20.normalizeUrl)(`${url2}${routes[0].pathname}`)
      )}
`
    ).join("");
  }
  let message = "";
  const maxNameLength = Math.max(...routes.map((r) => r.entryName.length));
  urls.forEach(({ label, url: url2 }, index) => {
    if (index > 0) {
      message += "\n";
    }
    message += `  ${`> ${label}`}
`;
    for (const r of routes) {
      message += `  ${import_shared20.color.dim("-")} ${import_shared20.color.dim(
        r.entryName.padEnd(maxNameLength + 4)
      )}${import_shared20.color.cyan((0, import_shared20.normalizeUrl)(`${url2}${r.pathname}`))}
`;
    }
  });
  return message;
}
function printServerURLs({
  urls: originalUrls,
  port,
  routes,
  protocol,
  printUrls
}) {
  if (printUrls === false) {
    return;
  }
  let urls = originalUrls;
  if ((0, import_shared20.isFunction)(printUrls)) {
    const newUrls = printUrls({
      urls: urls.map((item) => item.url),
      port,
      routes,
      protocol
    });
    if (!newUrls) {
      return;
    }
    if (!Array.isArray(newUrls)) {
      throw new Error(
        `"server.printUrls" must return an array, but got ${typeof newUrls}.`
      );
    }
    urls = newUrls.map((url2) => ({
      url: url2,
      label: getUrlLabel(url2)
    }));
  }
  if (urls.length === 0) {
    return;
  }
  const message = getURLMessages(urls, routes);
  import_shared20.logger.log(message);
  return message;
}
var import_node_net, import_node_os, import_shared20, formatPrefix, formatRoutes, HMR_SOCK_PATH, getPort, getServerConfig, getDevConfig, getIpv4Interfaces, isLoopbackHost, getHostInUrl, concatUrl, LOCAL_LABEL, NETWORK_LABEL, getUrlLabel, getAddressUrls;
var init_helper = __esm({
  "src/server/helper.ts"() {
    "use strict";
    import_node_net = __toESM(require("net"));
    import_node_os = __toESM(require("os"));
    import_shared20 = require("@rsbuild/shared");
    init_constants();
    formatPrefix = (prefix) => {
      if (!prefix) {
        return "/";
      }
      const hasLeadingSlash = prefix.startsWith("/");
      const hasTailSlash = prefix.endsWith("/");
      return `${hasLeadingSlash ? "" : "/"}${prefix}${hasTailSlash ? "" : "/"}`;
    };
    formatRoutes = (entry, prefix, outputStructure) => {
      const formattedPrefix = formatPrefix(prefix);
      return Object.keys(entry).map((entryName) => {
        const isIndex = entryName === "index" && outputStructure !== "nested";
        const displayName = isIndex ? "" : entryName;
        return {
          entryName,
          pathname: formattedPrefix + displayName
        };
      }).sort((a) => a.entryName === "index" ? -1 : 1);
    };
    HMR_SOCK_PATH = "/rsbuild-hmr";
    getPort = async ({
      host,
      port,
      strictPort,
      tryLimits = 20,
      silent = false
    }) => {
      if (typeof port === "string") {
        port = Number.parseInt(port, 10);
      }
      if (strictPort) {
        tryLimits = 1;
      }
      const original = port;
      let found = false;
      let attempts = 0;
      while (!found && attempts <= tryLimits) {
        try {
          await new Promise((resolve, reject) => {
            const server = import_node_net.default.createServer();
            server.unref();
            server.on("error", reject);
            server.listen({ port, host }, () => {
              found = true;
              server.close(resolve);
            });
          });
        } catch (e) {
          if (e.code !== "EADDRINUSE") {
            throw e;
          }
          port++;
          attempts++;
        }
      }
      if (port !== original) {
        if (strictPort) {
          throw new Error(
            `Port "${original}" is occupied, please choose another one.`
          );
        }
        if (!silent) {
          import_shared20.logger.info(
            `Port ${original} is in use, ${import_shared20.color.yellow(`using port ${port}.`)}
`
          );
        }
      }
      return port;
    };
    getServerConfig = async ({
      config,
      getPortSilently
    }) => {
      const host = config.server.host || DEFAULT_DEV_HOST;
      const port = await getPort({
        host,
        port: config.server.port || DEFAULT_PORT,
        strictPort: config.server.strictPort || false,
        silent: getPortSilently
      });
      const https = Boolean(config.server.https) || false;
      return { port, host, https };
    };
    getDevConfig = ({
      config,
      port
    }) => {
      const defaultDevConfig = {
        client: {
          path: HMR_SOCK_PATH,
          port: port.toString(),
          // By default it is set to "location.hostname"
          host: "",
          // By default it is set to "location.protocol === 'https:' ? 'wss' : 'ws'""
          protocol: void 0
        },
        writeToDisk: false,
        liveReload: true
      };
      const devConfig = config.dev ? (0, import_shared20.deepmerge)(defaultDevConfig, config.dev) : defaultDevConfig;
      return devConfig;
    };
    getIpv4Interfaces = () => {
      const interfaces = import_node_os.default.networkInterfaces();
      const ipv4Interfaces = /* @__PURE__ */ new Map();
      for (const key of Object.keys(interfaces)) {
        for (const detail of interfaces[key]) {
          const familyV4Value = typeof detail.family === "string" ? "IPv4" : 4;
          if (detail.family === familyV4Value && !ipv4Interfaces.has(detail.address)) {
            ipv4Interfaces.set(detail.address, detail);
          }
        }
      }
      return Array.from(ipv4Interfaces.values());
    };
    isLoopbackHost = (host) => {
      const loopbackHosts = [
        "localhost",
        "127.0.0.1",
        "::1",
        "0000:0000:0000:0000:0000:0000:0000:0001"
      ];
      return loopbackHosts.includes(host);
    };
    getHostInUrl = (host) => {
      if (import_node_net.default.isIPv6(host)) {
        return host === "::" ? "[::1]" : `[${host}]`;
      }
      return host;
    };
    concatUrl = ({
      host,
      port,
      protocol
    }) => `${protocol}://${host}:${port}`;
    LOCAL_LABEL = "Local:  ";
    NETWORK_LABEL = "Network:  ";
    getUrlLabel = (url2) => {
      try {
        const { host } = new URL(url2);
        return isLoopbackHost(host) ? LOCAL_LABEL : NETWORK_LABEL;
      } catch (err) {
        return NETWORK_LABEL;
      }
    };
    getAddressUrls = ({
      protocol = "http",
      port,
      host
    }) => {
      if (host && host !== DEFAULT_DEV_HOST) {
        return [
          {
            label: isLoopbackHost(host) ? LOCAL_LABEL : NETWORK_LABEL,
            url: concatUrl({
              port,
              host: getHostInUrl(host),
              protocol
            })
          }
        ];
      }
      const ipv4Interfaces = getIpv4Interfaces();
      const addressUrls = [];
      let hasLocalUrl = false;
      for (const detail of ipv4Interfaces) {
        if (isLoopbackHost(detail.address) || detail.internal) {
          if (hasLocalUrl) {
            continue;
          }
          addressUrls.push({
            label: LOCAL_LABEL,
            url: concatUrl({ host: "localhost", port, protocol })
          });
          hasLocalUrl = true;
        } else {
          addressUrls.push({
            label: NETWORK_LABEL,
            url: concatUrl({ host: detail.address, port, protocol })
          });
        }
      }
      return addressUrls;
    };
  }
});

// src/server/httpServer.ts
var createHttpServer;
var init_httpServer = __esm({
  "src/server/httpServer.ts"() {
    "use strict";
    createHttpServer = async ({
      serverConfig,
      middlewares
    }) => {
      if (serverConfig.https) {
        if (serverConfig.proxy) {
          const { createServer: createServer2 } = await import("https");
          return createServer2(serverConfig.https, middlewares);
        }
        const { createSecureServer } = await import("http2");
        return createSecureServer(
          {
            allowHTTP1: true,
            // increase the maximum memory (MiB)
            maxSessionMemory: 1024,
            ...serverConfig.https
          },
          // @ts-expect-error req type mismatch
          middlewares
        );
      }
      const { createServer } = await import("http");
      return createServer(middlewares);
    };
  }
});

// src/server/watchFiles.ts
async function setupWatchFiles(options) {
  const { dev, server, compileMiddlewareAPI } = options;
  const { hmr, liveReload } = dev;
  if (!hmr && !liveReload || !compileMiddlewareAPI) {
    return;
  }
  const devFilesWatcher = await watchDevFiles(dev, compileMiddlewareAPI);
  const serverFilesWatcher = await watchServerFiles(
    server,
    compileMiddlewareAPI
  );
  return {
    async close() {
      await Promise.all([
        devFilesWatcher?.close(),
        serverFilesWatcher?.close()
      ]);
    }
  };
}
async function watchDevFiles(devConfig, compileMiddlewareAPI) {
  const { watchFiles: watchFiles2 } = devConfig;
  if (!watchFiles2) {
    return;
  }
  const watchOptions = prepareWatchOptions(
    watchFiles2.paths,
    watchFiles2.options
  );
  return startWatchFiles(watchOptions, compileMiddlewareAPI);
}
function watchServerFiles(serverConfig, compileMiddlewareAPI) {
  const publicDirs = normalizePublicDirs(serverConfig.publicDir);
  if (!publicDirs.length) {
    return;
  }
  const watchPaths = publicDirs.filter((item) => item.watch).map((item) => item.name);
  if (!watchPaths.length) {
    return;
  }
  const watchOptions = prepareWatchOptions(watchPaths);
  return startWatchFiles(watchOptions, compileMiddlewareAPI);
}
function prepareWatchOptions(paths, options = {}) {
  return {
    paths: typeof paths === "string" ? [paths] : paths,
    options
  };
}
async function startWatchFiles({ paths, options }, compileMiddlewareAPI) {
  const chokidar = await import("@rsbuild/shared/chokidar");
  const watcher = chokidar.watch(paths, options);
  watcher.on("change", () => {
    compileMiddlewareAPI.sockWrite("static-changed");
  });
  return watcher;
}
var init_watchFiles = __esm({
  "src/server/watchFiles.ts"() {
    "use strict";
    init_config();
  }
});

// src/server/socketServer.ts
var import_shared21, SocketServer;
var init_socketServer = __esm({
  "src/server/socketServer.ts"() {
    "use strict";
    import_shared21 = require("@rsbuild/shared");
    init_helpers();
    SocketServer = class {
      constructor(options) {
        __publicField(this, "wsServer");
        __publicField(this, "sockets", []);
        __publicField(this, "options");
        __publicField(this, "stats");
        __publicField(this, "timer", null);
        this.options = options;
      }
      upgrade(req, sock, head) {
        if (!this.wsServer.shouldHandle(req)) {
          return;
        }
        this.wsServer.handleUpgrade(req, sock, head, (connection) => {
          this.wsServer.emit("connection", connection, req);
        });
      }
      // create socket, install socket handler, bind socket event
      async prepare() {
        const { default: ws } = await import("../compiled/ws/index.js");
        this.wsServer = new ws.Server({
          noServer: true,
          path: this.options.client?.path
        });
        this.wsServer.on("error", (err) => {
          import_shared21.logger.error(err);
        });
        this.timer = setInterval(() => {
          for (const socket of this.wsServer.clients) {
            const extWs = socket;
            if (!extWs.isAlive) {
              extWs.terminate();
            } else {
              extWs.isAlive = false;
              extWs.ping(() => {
              });
            }
          }
        }, 3e4);
        this.wsServer.on("connection", (socket) => {
          this.onConnect(socket);
        });
      }
      updateStats(stats) {
        this.stats = stats;
        this.sendStats();
      }
      // write message to each socket
      sockWrite(type, data) {
        for (const socket of this.sockets) {
          this.send(socket, JSON.stringify({ type, data }));
        }
      }
      singleWrite(socket, type, data) {
        this.send(socket, JSON.stringify({ type, data }));
      }
      close() {
        for (const socket of this.sockets) {
          socket.close();
        }
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
      }
      onConnect(socket) {
        const connection = socket;
        connection.isAlive = true;
        connection.on("pong", () => {
          connection.isAlive = true;
        });
        if (!connection) {
          return;
        }
        this.sockets.push(connection);
        connection.on("close", () => {
          const idx = this.sockets.indexOf(connection);
          if (idx >= 0) {
            this.sockets.splice(idx, 1);
          }
        });
        if (this.options.hmr || this.options.liveReload) {
          this.singleWrite(connection, "hot");
        }
        if (this.stats) {
          this.sendStats(true);
        }
      }
      // get standard stats
      getStats() {
        const curStats = this.stats;
        if (!curStats) {
          return null;
        }
        const defaultStats = {
          all: false,
          hash: true,
          assets: true,
          warnings: true,
          warningsCount: true,
          errors: true,
          errorsCount: true,
          errorDetails: false,
          children: true
        };
        return curStats.toJson(defaultStats);
      }
      // determine what message should send by stats
      sendStats(force = false) {
        const stats = this.getStats();
        if (!stats) {
          return null;
        }
        const shouldEmit = !force && stats && !stats.errorsCount && stats.assets && stats.assets.every((asset) => !asset.emitted);
        if (shouldEmit) {
          return this.sockWrite("still-ok");
        }
        this.sockWrite("hash", stats.hash);
        if (stats.errorsCount) {
          return this.sockWrite("errors", getAllStatsErrors(stats));
        }
        if (stats.warningsCount) {
          return this.sockWrite("warnings", getAllStatsWarnings(stats));
        }
        return this.sockWrite("ok");
      }
      // send message to connecting socket
      send(connection, message) {
        if (connection.readyState !== 1) {
          return;
        }
        connection.send(message);
      }
    };
  }
});

// src/server/compilerDevMiddleware.ts
var compilerDevMiddleware_exports = {};
__export(compilerDevMiddleware_exports, {
  CompilerDevMiddleware: () => CompilerDevMiddleware
});
function getClientPaths(devConfig) {
  const clientPaths = [];
  if (!devConfig.hmr && !devConfig.liveReload) {
    return clientPaths;
  }
  clientPaths.push(require.resolve("@rsbuild/core/client/hmr"));
  if (devConfig.client?.overlay) {
    clientPaths.push(`${require.resolve("@rsbuild/core/client/overlay")}`);
  }
  return clientPaths;
}
var noop, CompilerDevMiddleware;
var init_compilerDevMiddleware = __esm({
  "src/server/compilerDevMiddleware.ts"() {
    "use strict";
    init_socketServer();
    noop = () => {
    };
    CompilerDevMiddleware = class {
      constructor({ dev, server, devMiddleware, publicPaths }) {
        __publicField(this, "middleware");
        __publicField(this, "devConfig");
        __publicField(this, "serverConfig");
        __publicField(this, "devMiddleware");
        __publicField(this, "publicPaths");
        __publicField(this, "socketServer");
        this.devConfig = dev;
        this.serverConfig = server;
        this.publicPaths = publicPaths;
        this.socketServer = new SocketServer(dev);
        this.devMiddleware = devMiddleware;
      }
      async init() {
        this.middleware = this.setupDevMiddleware(
          this.devMiddleware,
          this.publicPaths
        );
        await this.socketServer.prepare();
      }
      upgrade(req, sock, head) {
        this.socketServer.upgrade(req, sock, head);
      }
      close() {
        this.socketServer.close();
        this.middleware?.close(noop);
      }
      sockWrite(type, data) {
        this.socketServer.sockWrite(type, data);
      }
      setupDevMiddleware(devMiddleware, publicPaths) {
        const { devConfig, serverConfig } = this;
        const callbacks = {
          onInvalid: () => {
            this.socketServer.sockWrite("invalid");
          },
          onDone: (stats) => {
            this.socketServer.updateStats(stats);
          }
        };
        const clientPaths = getClientPaths(devConfig);
        const middleware = devMiddleware({
          headers: serverConfig.headers,
          publicPath: "/",
          stats: false,
          callbacks,
          clientPaths,
          clientConfig: devConfig.client,
          liveReload: devConfig.liveReload,
          writeToDisk: devConfig.writeToDisk,
          serverSideRender: true,
          // weak is enough in dev
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests#weak_validation
          etag: "weak"
        });
        const warp = async (req, res, next) => {
          const { url: url2 } = req;
          const assetPrefix = url2 && publicPaths.find((prefix) => url2.startsWith(prefix));
          if (assetPrefix && assetPrefix !== "/") {
            req.url = url2.slice(assetPrefix.length - 1);
            middleware(req, res, (...args) => {
              req.url = url2;
              next(...args);
            });
          } else {
            middleware(req, res, next);
          }
        };
        warp.close = middleware.close;
        return warp;
      }
    };
  }
});

// src/server/devServer.ts
var devServer_exports = {};
__export(devServer_exports, {
  createDevServer: () => createDevServer
});
async function createDevServer(options, createDevMiddleware2, config, {
  compiler: customCompiler,
  getPortSilently,
  runCompile = true
} = {}) {
  if (!(0, import_shared22.getNodeEnv)()) {
    (0, import_shared22.setNodeEnv)("development");
  }
  (0, import_shared22.debug)("create dev server");
  const serverConfig = config.server;
  const { port, host, https } = await getServerConfig({
    config,
    getPortSilently
  });
  const devConfig = getDevConfig({
    config,
    port
  });
  const routes = formatRoutes(
    options.context.entry,
    config.output.distPath.html,
    config.html.outputStructure
  );
  options.context.devServer = {
    hostname: host,
    port,
    https
  };
  let outputFileSystem = import_node_fs3.default;
  const startCompile = async () => {
    const { devMiddleware, compiler } = await createDevMiddleware2(
      options,
      customCompiler
    );
    const { CompilerDevMiddleware: CompilerDevMiddleware2 } = await Promise.resolve().then(() => (init_compilerDevMiddleware(), compilerDevMiddleware_exports));
    const publicPaths = (0, import_shared22.isMultiCompiler)(compiler) ? compiler.compilers.map(import_shared22.getPublicPathFromCompiler) : [(0, import_shared22.getPublicPathFromCompiler)(compiler)];
    const compilerDevMiddleware = new CompilerDevMiddleware2({
      dev: devConfig,
      server: serverConfig,
      publicPaths,
      devMiddleware
    });
    await compilerDevMiddleware.init();
    outputFileSystem = ((0, import_shared22.isMultiCompiler)(compiler) ? compiler.compilers[0].outputFileSystem : compiler.outputFileSystem) || import_node_fs3.default;
    return {
      middleware: compilerDevMiddleware.middleware,
      sockWrite: (...args) => compilerDevMiddleware.sockWrite(...args),
      onUpgrade: (...args) => compilerDevMiddleware.upgrade(...args),
      close: () => compilerDevMiddleware?.close()
    };
  };
  const protocol = https ? "https" : "http";
  const urls = getAddressUrls({ protocol, port, host });
  await options.context.hooks.onBeforeStartDevServer.call();
  if (runCompile) {
    options.context.hooks.onBeforeCreateCompiler.tap(() => {
      printServerURLs({
        urls,
        port,
        routes,
        protocol,
        printUrls: serverConfig.printUrls
      });
    });
  } else {
    printServerURLs({
      urls,
      port,
      routes,
      protocol,
      printUrls: serverConfig.printUrls
    });
  }
  const compileMiddlewareAPI = runCompile ? await startCompile() : void 0;
  const fileWatcher = await setupWatchFiles({
    dev: devConfig,
    server: serverConfig,
    compileMiddlewareAPI
  });
  const devMiddlewares = await getMiddlewares({
    pwd: options.context.rootPath,
    compileMiddlewareAPI,
    dev: devConfig,
    server: serverConfig,
    output: {
      distPath: config.output.distPath.root || ROOT_DIST_DIR
    },
    outputFileSystem
  });
  const { default: connect } = await import("../compiled/connect/index.js");
  const middlewares = connect();
  for (const item of devMiddlewares.middlewares) {
    if (Array.isArray(item)) {
      middlewares.use(...item);
    } else {
      middlewares.use(item);
    }
  }
  const server = {
    port,
    middlewares,
    outputFileSystem,
    listen: async () => {
      const httpServer = await createHttpServer({
        serverConfig,
        middlewares
      });
      (0, import_shared22.debug)("listen dev server");
      return new Promise((resolve) => {
        httpServer.listen(
          {
            host,
            port
          },
          async (err) => {
            if (err) {
              throw err;
            }
            middlewares.use(notFoundMiddleware);
            httpServer.on("upgrade", devMiddlewares.onUpgrade);
            (0, import_shared22.debug)("listen dev server done");
            await server.afterListen();
            const closeServer = async () => {
              await server.close();
              httpServer.close();
            };
            onBeforeRestartServer(closeServer);
            resolve({
              port,
              urls: urls.map((item) => item.url),
              server: {
                close: closeServer
              }
            });
          }
        );
      });
    },
    afterListen: async () => {
      await options.context.hooks.onAfterStartDevServer.call({
        port,
        routes
      });
    },
    onHTTPUpgrade: devMiddlewares.onUpgrade,
    close: async () => {
      await options.context.hooks.onCloseDevServer.call();
      await devMiddlewares.close();
      await fileWatcher?.close();
    }
  };
  (0, import_shared22.debug)("create dev server done");
  return server;
}
var import_node_fs3, import_shared22;
var init_devServer = __esm({
  "src/server/devServer.ts"() {
    "use strict";
    import_node_fs3 = __toESM(require("fs"));
    import_shared22 = require("@rsbuild/shared");
    init_constants();
    init_getDevMiddlewares();
    init_helper();
    init_httpServer();
    init_middlewares();
    init_restart();
    init_watchFiles();
  }
});

// src/server/prodServer.ts
var prodServer_exports = {};
__export(prodServer_exports, {
  RsbuildProdServer: () => RsbuildProdServer,
  startProdServer: () => startProdServer
});
async function startProdServer(context, config, { getPortSilently } = {}) {
  if (!(0, import_shared23.getNodeEnv)()) {
    (0, import_shared23.setNodeEnv)("production");
  }
  const { port, host, https } = await getServerConfig({
    config,
    getPortSilently
  });
  const { default: connect } = await import("../compiled/connect/index.js");
  const middlewares = connect();
  const serverConfig = config.server;
  const server = new RsbuildProdServer(
    {
      pwd: context.rootPath,
      output: {
        path: config.output.distPath.root || ROOT_DIST_DIR,
        assetPrefix: config.output.assetPrefix
      },
      serverConfig
    },
    middlewares
  );
  await context.hooks.onBeforeStartProdServer.call();
  const httpServer = await createHttpServer({
    serverConfig,
    middlewares: server.middlewares
  });
  await server.onInit(httpServer);
  return new Promise((resolve) => {
    httpServer.listen(
      {
        host,
        port
      },
      async () => {
        const routes = formatRoutes(
          context.entry,
          config.output.distPath.html,
          config.html.outputStructure
        );
        await context.hooks.onAfterStartProdServer.call({
          port,
          routes
        });
        const protocol = https ? "https" : "http";
        const urls = getAddressUrls({ protocol, port, host });
        printServerURLs({
          urls,
          port,
          routes,
          protocol,
          printUrls: serverConfig.printUrls
        });
        const onClose = () => {
          server.close();
          httpServer.close();
        };
        resolve({
          port,
          urls: urls.map((item) => item.url),
          server: {
            close: async () => {
              onClose();
            }
          }
        });
      }
    );
  });
}
var import_node_path11, import_shared23, RsbuildProdServer;
var init_prodServer = __esm({
  "src/server/prodServer.ts"() {
    "use strict";
    import_node_path11 = require("path");
    import_shared23 = require("@rsbuild/shared");
    init_constants();
    init_helper();
    init_httpServer();
    init_middlewares();
    RsbuildProdServer = class {
      constructor(options, middlewares) {
        __publicField(this, "app");
        __publicField(this, "options");
        __publicField(this, "middlewares");
        this.options = options;
        this.middlewares = middlewares;
      }
      // Complete the preparation of services
      async onInit(app) {
        this.app = app;
        await this.applyDefaultMiddlewares();
      }
      async applyDefaultMiddlewares() {
        const { headers, proxy, historyApiFallback, compress } = this.options.serverConfig;
        if ((0, import_shared23.isDebug)()) {
          this.middlewares.use(await getRequestLoggerMiddleware());
        }
        if (compress) {
          const { default: compression } = await import("../compiled/http-compression/index.js");
          this.middlewares.use((req, res, next) => {
            compression({
              gzip: true,
              brotli: false
            })(req, res, next);
          });
        }
        if (headers) {
          this.middlewares.use((_req, res, next) => {
            for (const [key, value] of Object.entries(headers)) {
              res.setHeader(key, value);
            }
            next();
          });
        }
        if (proxy) {
          const { createProxyMiddleware: createProxyMiddleware2 } = await Promise.resolve().then(() => (init_proxy(), proxy_exports));
          const { middlewares, upgrade } = createProxyMiddleware2(proxy);
          for (const middleware of middlewares) {
            this.middlewares.use(middleware);
          }
          this.app.on("upgrade", upgrade);
        }
        this.applyStaticAssetMiddleware();
        if (historyApiFallback) {
          const { default: connectHistoryApiFallback } = await import("../compiled/connect-history-api-fallback/index.js");
          const historyApiFallbackMiddleware = connectHistoryApiFallback(
            historyApiFallback === true ? {} : historyApiFallback
          );
          this.middlewares.use(historyApiFallbackMiddleware);
          await this.applyStaticAssetMiddleware();
        }
        this.middlewares.use(faviconFallbackMiddleware);
      }
      async applyStaticAssetMiddleware() {
        const {
          output: { path: path13, assetPrefix },
          serverConfig: { htmlFallback },
          pwd
        } = this.options;
        const { default: sirv } = await import("../compiled/sirv/index.js");
        const assetMiddleware = sirv((0, import_node_path11.join)(pwd, path13), {
          etag: true,
          dev: true,
          ignores: ["favicon.ico"],
          single: htmlFallback === "index"
        });
        this.middlewares.use((req, res, next) => {
          const url2 = req.url;
          if (assetPrefix && url2?.startsWith(assetPrefix)) {
            req.url = url2.slice(assetPrefix.length);
            assetMiddleware(req, res, (...args) => {
              req.url = url2;
              next(...args);
            });
          } else {
            assetMiddleware(req, res, next);
          }
        });
      }
      close() {
      }
    };
  }
});

// src/provider/build.ts
var build_exports = {};
__export(build_exports, {
  build: () => build
});
var import_shared24, import_core4, build;
var init_build = __esm({
  "src/provider/build.ts"() {
    "use strict";
    import_shared24 = require("@rsbuild/shared");
    import_core4 = require("@rspack/core");
    init_createCompiler();
    init_initConfigs();
    build = async (initOptions, { mode = "production", watch, compiler: customCompiler } = {}) => {
      if (!(0, import_shared24.getNodeEnv)()) {
        (0, import_shared24.setNodeEnv)(mode);
      }
      const { context } = initOptions;
      let compiler;
      let bundlerConfigs;
      if (customCompiler) {
        compiler = customCompiler;
      } else {
        const { rspackConfigs } = await initConfigs(initOptions);
        compiler = await createCompiler({
          context,
          rspackConfigs
        });
        bundlerConfigs = rspackConfigs;
      }
      let isFirstCompile = true;
      await context.hooks.onBeforeBuild.call({
        bundlerConfigs
      });
      const onDone = async (stats) => {
        const p = context.hooks.onAfterBuild.call({ isFirstCompile, stats });
        isFirstCompile = false;
        await p;
      };
      (0, import_shared24.onCompileDone)(
        compiler,
        onDone,
        // @ts-expect-error type mismatch
        import_core4.rspack.MultiStats
      );
      if (watch) {
        compiler.watch({}, (err) => {
          if (err) {
            import_shared24.logger.error(err);
          }
        });
        return;
      }
      await new Promise((resolve, reject) => {
        compiler.run((err, stats) => {
          if (err || stats?.hasErrors()) {
            const buildError = err || new Error("Rspack build failed!");
            reject(buildError);
          } else {
            compiler.close((closeErr) => {
              if (closeErr) {
                import_shared24.logger.error(closeErr);
              }
              resolve({ stats });
            });
          }
        });
      });
    };
  }
});

// src/provider/provider.ts
var provider_exports = {};
__export(provider_exports, {
  rspackProvider: () => rspackProvider
});
var rspackProvider;
var init_provider = __esm({
  "src/provider/provider.ts"() {
    "use strict";
    init_initConfigs();
    rspackProvider = async ({
      context,
      pluginManager,
      rsbuildOptions
    }) => {
      const createCompiler2 = async () => {
        const { createCompiler: createCompiler3 } = await Promise.resolve().then(() => (init_createCompiler(), createCompiler_exports));
        const { rspackConfigs } = await initConfigs({
          context,
          pluginManager,
          rsbuildOptions
        });
        return createCompiler3({
          context,
          rspackConfigs
        });
      };
      return {
        bundler: "rspack",
        createCompiler: createCompiler2,
        async createDevServer(options) {
          const { createDevServer: createDevServer2 } = await Promise.resolve().then(() => (init_devServer(), devServer_exports));
          const { createDevMiddleware: createDevMiddleware2 } = await Promise.resolve().then(() => (init_createCompiler(), createCompiler_exports));
          const config = await initRsbuildConfig({ context, pluginManager });
          return createDevServer2(
            { context, pluginManager, rsbuildOptions },
            createDevMiddleware2,
            config,
            options
          );
        },
        async startDevServer(options) {
          const { createDevServer: createDevServer2 } = await Promise.resolve().then(() => (init_devServer(), devServer_exports));
          const { createDevMiddleware: createDevMiddleware2 } = await Promise.resolve().then(() => (init_createCompiler(), createCompiler_exports));
          const config = await initRsbuildConfig({ context, pluginManager });
          const server = await createDevServer2(
            { context, pluginManager, rsbuildOptions },
            createDevMiddleware2,
            config,
            options
          );
          return server.listen();
        },
        async preview(options) {
          const { startProdServer: startProdServer2 } = await Promise.resolve().then(() => (init_prodServer(), prodServer_exports));
          const config = await initRsbuildConfig({ context, pluginManager });
          return startProdServer2(context, config, options);
        },
        async build(options) {
          const { build: build2 } = await Promise.resolve().then(() => (init_build(), build_exports));
          return build2({ context, pluginManager, rsbuildOptions }, options);
        },
        async initConfigs() {
          const { rspackConfigs } = await initConfigs({
            context,
            pluginManager,
            rsbuildOptions
          });
          return rspackConfigs;
        },
        async inspectConfig(inspectOptions) {
          const { inspectConfig: inspectConfig2 } = await Promise.resolve().then(() => (init_inspectConfig(), inspectConfig_exports));
          return inspectConfig2({
            context,
            pluginManager,
            rsbuildOptions,
            inspectOptions
          });
        }
      };
    };
  }
});

// src/plugins/basic.ts
var basic_exports = {};
__export(basic_exports, {
  pluginBasic: () => pluginBasic
});
var import_node_path12, import_shared25, pluginBasic;
var init_basic = __esm({
  "src/plugins/basic.ts"() {
    "use strict";
    import_node_path12 = __toESM(require("path"));
    import_shared25 = require("@rsbuild/shared");
    pluginBasic = () => ({
      name: "rsbuild:basic",
      setup(api) {
        api.modifyBundlerChain(
          (chain, { env, isProd: isProd6, target, bundler, CHAIN_ID: CHAIN_ID3 }) => {
            const config = api.getNormalizedConfig();
            chain.name(import_shared25.TARGET_ID_MAP[target]);
            chain.devtool((0, import_shared25.getJsSourceMap)(config));
            chain.context(api.context.rootPath);
            chain.mode(isProd6 ? "production" : "development");
            chain.merge({
              infrastructureLogging: {
                // Using `error` level to avoid `cache.PackFileCacheStrategy` logs
                level: "error"
              }
            });
            chain.performance.hints(false);
            chain.module.parser.merge({
              javascript: {
                exportsPresence: "error"
              }
            });
            const isMinimize = isProd6 && config.output.minify !== false;
            chain.optimization.minimize(isMinimize);
            const usingHMR = (0, import_shared25.isUsingHMR)(config, { target, isProd: isProd6 });
            if (usingHMR) {
              chain.plugin(CHAIN_ID3.PLUGIN.HMR).use(bundler.HotModuleReplacementPlugin);
            }
            if (env === "development") {
              chain.output.devtoolModuleFilenameTemplate(
                (info) => import_node_path12.default.resolve(info.absoluteResourcePath).replace(/\\/g, "/")
              );
            }
            process.env.RSPACK_CONFIG_VALIDATE = "loose-silent";
            process.env.WATCHPACK_WATCHER_LIMIT ||= "20";
          }
        );
      }
    });
  }
});

// src/plugins/cache.ts
var cache_exports = {};
__export(cache_exports, {
  pluginCache: () => pluginCache
});
async function validateCache(cacheDirectory, buildDependencies) {
  const configFile = (0, import_node_path13.join)(cacheDirectory, "buildDependencies.json");
  if (await isFileExists(configFile)) {
    const prevBuildDependencies = await import_shared26.fse.readJSON(configFile);
    if (JSON.stringify(prevBuildDependencies) === JSON.stringify(buildDependencies)) {
      return;
    }
    await import_shared26.fse.remove(cacheDirectory);
  }
  await import_shared26.fse.outputJSON(configFile, buildDependencies);
}
function getDigestHash(digest) {
  const fsHash = import_node_crypto.default.createHash("md5");
  const md5 = fsHash.update(JSON.stringify(digest)).digest("hex").slice(0, 8);
  return md5;
}
function getCacheDirectory({ cacheDirectory }, context) {
  if (cacheDirectory) {
    return (0, import_node_path13.isAbsolute)(cacheDirectory) ? cacheDirectory : (0, import_node_path13.join)(context.rootPath, cacheDirectory);
  }
  return (0, import_node_path13.join)(context.cachePath, context.bundlerType);
}
async function getBuildDependencies(context, config) {
  const rootPackageJson = (0, import_node_path13.join)(context.rootPath, "package.json");
  const browserslistConfig = (0, import_node_path13.join)(context.rootPath, ".browserslistrc");
  const buildDependencies = {};
  if (await isFileExists(rootPackageJson)) {
    buildDependencies.packageJson = [rootPackageJson];
  }
  if (context.tsconfigPath) {
    buildDependencies.tsconfig = [context.tsconfigPath];
  }
  if (config._privateMeta?.configFilePath) {
    buildDependencies.rsbuildConfig = [config._privateMeta.configFilePath];
  }
  if (await isFileExists(browserslistConfig)) {
    buildDependencies.browserslistrc = [browserslistConfig];
  }
  const tailwindExts = ["ts", "js", "cjs", "mjs"];
  const configs = tailwindExts.map(
    (ext) => (0, import_node_path13.join)(context.rootPath, `tailwind.config.${ext}`)
  );
  const tailwindConfig = findExists(configs);
  if (tailwindConfig) {
    buildDependencies.tailwindcss = [tailwindConfig];
  }
  return buildDependencies;
}
var import_node_crypto, import_node_path13, import_shared26, pluginCache;
var init_cache = __esm({
  "src/plugins/cache.ts"() {
    "use strict";
    import_node_crypto = __toESM(require("crypto"));
    import_node_path13 = require("path");
    import_shared26 = require("@rsbuild/shared");
    init_helpers();
    pluginCache = () => ({
      name: "rsbuild:cache",
      setup(api) {
        if (api.context.bundlerType === "rspack") {
          return;
        }
        api.modifyBundlerChain(async (chain, { target, env }) => {
          const config = api.getNormalizedConfig();
          const { buildCache } = config.performance;
          if (buildCache === false) {
            chain.cache(false);
            return;
          }
          const { context } = api;
          const cacheConfig = typeof buildCache === "boolean" ? {} : buildCache;
          const cacheDirectory = getCacheDirectory(cacheConfig, context);
          const buildDependencies = await getBuildDependencies(context, config);
          await validateCache(cacheDirectory, buildDependencies);
          const useDigest = Array.isArray(cacheConfig.cacheDigest) && cacheConfig.cacheDigest.length;
          chain.cache({
            // The default cache name of webpack is '${name}-${env}', and the `name` is `default` by default.
            // We set cache name to avoid cache conflicts of different targets.
            name: useDigest ? `${target}-${env}-${getDigestHash(cacheConfig.cacheDigest)}` : `${target}-${env}`,
            type: "filesystem",
            cacheDirectory,
            buildDependencies
          });
        });
      }
    });
  }
});

// src/plugins/target.ts
var target_exports = {};
__export(target_exports, {
  pluginTarget: () => pluginTarget
});
var import_shared27, pluginTarget;
var init_target = __esm({
  "src/plugins/target.ts"() {
    "use strict";
    import_shared27 = require("@rsbuild/shared");
    pluginTarget = () => ({
      name: "rsbuild:target",
      setup(api) {
        api.modifyBundlerChain({
          order: "pre",
          handler: async (chain, { target }) => {
            if (target === "node") {
              chain.target("node");
              return;
            }
            const config = api.getNormalizedConfig();
            const browserslist = await (0, import_shared27.getBrowserslistWithDefault)(
              api.context.rootPath,
              config,
              target
            );
            const esVersion = (0, import_shared27.browserslistToESVersion)(browserslist);
            if (target === "web-worker" || target === "service-worker") {
              chain.target(["webworker", `es${esVersion}`]);
              return;
            }
            chain.target(["web", `es${esVersion}`]);
          }
        });
      }
    });
  }
});

// src/plugins/css.ts
var css_exports = {};
__export(css_exports, {
  applyAutoprefixer: () => applyAutoprefixer,
  enableNativeCss: () => enableNativeCss,
  isUseCssExtract: () => isUseCssExtract,
  normalizeCssLoaderOptions: () => normalizeCssLoaderOptions,
  pluginCss: () => pluginCss
});
async function loadUserPostcssrc(root) {
  const cached = userPostcssrcCache.get(root);
  if (cached) {
    return cached;
  }
  const { default: postcssrc } = await import("../compiled/postcss-load-config/index.js");
  const promise = postcssrc({}, root).catch((err) => {
    if (err.message?.includes("No PostCSS Config found")) {
      return {};
    }
    throw err;
  });
  userPostcssrcCache.set(root, promise);
  promise.then((config) => {
    userPostcssrcCache.set(root, config);
  });
  return promise;
}
async function applyCSSRule({
  rule,
  config,
  context,
  utils: { target, isProd: isProd6, CHAIN_ID: CHAIN_ID3 },
  importLoaders = 1
}) {
  const browserslist = await (0, import_shared28.getBrowserslistWithDefault)(
    context.rootPath,
    config,
    target
  );
  const enableExtractCSS = isUseCssExtract(config, target);
  const localIdentName = getCSSModulesLocalIdentName(config, isProd6);
  const cssLoaderOptions = getCSSLoaderOptions({
    config,
    importLoaders,
    target,
    localIdentName
  });
  if (target === "web") {
    if (enableExtractCSS) {
      rule.use(CHAIN_ID3.USE.MINI_CSS_EXTRACT).loader(getCssExtractPlugin().loader).options(config.tools.cssExtract.loaderOptions).end();
    } else {
      const styleLoaderOptions = (0, import_shared28.reduceConfigs)({
        initial: {},
        config: config.tools.styleLoader
      });
      rule.use(CHAIN_ID3.USE.STYLE).loader(getCompiledPath("style-loader")).options(styleLoaderOptions).end();
    }
  } else {
    rule.use(CHAIN_ID3.USE.IGNORE_CSS).loader(import_node_path14.default.join(LOADER_PATH, "ignoreCssLoader.cjs")).end();
  }
  rule.use(CHAIN_ID3.USE.CSS).loader(getCompiledPath("css-loader")).options(cssLoaderOptions).end();
  if (target === "web") {
    const postcssLoaderOptions = await getPostcssLoaderOptions({
      browserslist,
      config,
      root: context.rootPath
    });
    rule.use(CHAIN_ID3.USE.POSTCSS).loader(getCompiledPath("postcss-loader")).options(postcssLoaderOptions).end();
  }
  rule.merge({ sideEffects: true });
  rule.resolve.preferRelative(true);
}
var import_node_path14, import_shared28, enableNativeCss, isUseCssExtract, getCSSModulesLocalIdentName, normalizeCssLoaderOptions, userPostcssrcCache, applyAutoprefixer, getPostcssLoaderOptions, getCSSLoaderOptions, pluginCss;
var init_css = __esm({
  "src/plugins/css.ts"() {
    "use strict";
    import_node_path14 = __toESM(require("path"));
    import_shared28 = require("@rsbuild/shared");
    init_constants();
    init_helpers();
    init_pluginHelper();
    enableNativeCss = (config) => !config.output.injectStyles;
    isUseCssExtract = (config, target) => !config.output.injectStyles && target !== "node" && target !== "web-worker";
    getCSSModulesLocalIdentName = (config, isProd6) => config.output.cssModules.localIdentName || // Using shorter classname in production to reduce bundle size
    (isProd6 ? "[local]-[hash:base64:6]" : "[path][name]__[local]-[hash:base64:6]");
    normalizeCssLoaderOptions = (options, exportOnlyLocals) => {
      if (options.modules && exportOnlyLocals) {
        let { modules } = options;
        if (modules === true) {
          modules = { exportOnlyLocals: true };
        } else if (typeof modules === "string") {
          modules = {
            mode: modules,
            exportOnlyLocals: true
          };
        } else {
          modules = {
            ...modules,
            exportOnlyLocals: true
          };
        }
        return {
          ...options,
          modules
        };
      }
      return options;
    };
    userPostcssrcCache = /* @__PURE__ */ new Map();
    applyAutoprefixer = async (plugins, browserslist, config) => {
      const pluginObjects = plugins.map(
        (plugin) => (0, import_shared28.isFunction)(plugin) ? plugin({}) : plugin
      );
      const hasAutoprefixer = pluginObjects.some((pluginObject) => {
        if ((0, import_shared28.isPlainObject)(pluginObject) && "postcssPlugin" in pluginObject) {
          return pluginObject.postcssPlugin === "autoprefixer";
        }
        return false;
      });
      if (!hasAutoprefixer) {
        const { default: autoprefixer } = await import("@rsbuild/shared/autoprefixer");
        const autoprefixerOptions = (0, import_shared28.reduceConfigs)({
          initial: {
            flexbox: "no-2009",
            overrideBrowserslist: browserslist
          },
          config: config.tools.autoprefixer
        });
        pluginObjects.push(autoprefixer(autoprefixerOptions));
      }
      return pluginObjects;
    };
    getPostcssLoaderOptions = async ({
      browserslist,
      config,
      root
    }) => {
      const extraPlugins = [];
      const utils = {
        addPlugins(plugins) {
          if (Array.isArray(plugins)) {
            extraPlugins.push(...plugins);
          } else {
            extraPlugins.push(plugins);
          }
        }
      };
      const userPostcssConfig = await loadUserPostcssrc(root);
      let postcssPlugins = userPostcssConfig.plugins?.slice() || [];
      postcssPlugins = await applyAutoprefixer(
        postcssPlugins,
        browserslist,
        config
      );
      const defaultPostcssConfig = {
        postcssOptions: {
          ...userPostcssConfig,
          plugins: postcssPlugins
        },
        sourceMap: config.output.sourceMap.css
      };
      const mergedConfig = (0, import_shared28.reduceConfigsWithContext)({
        initial: defaultPostcssConfig,
        config: config.tools.postcss,
        ctx: utils
      });
      if (extraPlugins.length) {
        mergedConfig?.postcssOptions?.plugins.push(...extraPlugins);
      }
      mergedConfig.postcssOptions ||= {};
      mergedConfig.postcssOptions.config = false;
      return mergedConfig;
    };
    getCSSLoaderOptions = ({
      config,
      importLoaders,
      target,
      localIdentName
    }) => {
      const { cssModules } = config.output;
      const defaultOptions2 = {
        importLoaders,
        modules: {
          ...cssModules,
          localIdentName
        },
        sourceMap: config.output.sourceMap.css
      };
      const mergedCssLoaderOptions = (0, import_shared28.reduceConfigs)({
        initial: defaultOptions2,
        config: config.tools.cssLoader,
        mergeFn: import_shared28.deepmerge
      });
      const cssLoaderOptions = normalizeCssLoaderOptions(
        mergedCssLoaderOptions,
        target !== "web"
      );
      return cssLoaderOptions;
    };
    pluginCss = () => ({
      name: "rsbuild:css",
      setup(api) {
        api.modifyBundlerChain({
          order: "pre",
          handler: async (chain, utils) => {
            const rule = chain.module.rule(utils.CHAIN_ID.RULE.CSS);
            const config = api.getNormalizedConfig();
            rule.test(CSS_REGEX);
            await applyCSSRule({
              rule,
              utils,
              config,
              context: api.context
            });
          }
        });
        api.modifyRspackConfig(async (rspackConfig) => {
          rspackConfig.experiments ||= {};
          rspackConfig.experiments.css = false;
        });
      }
    });
  }
});

// src/plugins/output.ts
var output_exports = {};
__export(output_exports, {
  pluginOutput: () => pluginOutput
});
function getPublicPath({
  isProd: isProd6,
  config,
  context
}) {
  const { dev, output } = config;
  let publicPath = import_shared29.DEFAULT_ASSET_PREFIX;
  if (isProd6) {
    if (typeof output.assetPrefix === "string") {
      publicPath = output.assetPrefix;
    }
  } else if (typeof dev.assetPrefix === "string") {
    publicPath = dev.assetPrefix;
  } else if (dev.assetPrefix === true) {
    const protocol = context.devServer?.https ? "https" : "http";
    const hostname = context.devServer?.hostname || DEFAULT_DEV_HOST;
    const port = context.devServer?.port || DEFAULT_PORT;
    if (hostname === DEFAULT_DEV_HOST) {
      const localHostname = "localhost";
      publicPath = `${protocol}://${localHostname}:${port}/`;
    } else {
      publicPath = `${protocol}://${hostname}:${port}/`;
    }
  }
  return formatPublicPath(publicPath);
}
var import_node_path15, import_shared29, import_core5, pluginOutput;
var init_output = __esm({
  "src/plugins/output.ts"() {
    "use strict";
    import_node_path15 = require("path");
    import_shared29 = require("@rsbuild/shared");
    import_core5 = require("@rspack/core");
    init_constants();
    init_helpers();
    init_pluginHelper();
    init_css();
    pluginOutput = () => ({
      name: "rsbuild:output",
      setup(api) {
        api.modifyBundlerChain(
          async (chain, { CHAIN_ID: CHAIN_ID3, target, isProd: isProd6, isServer, isServiceWorker }) => {
            const config = api.getNormalizedConfig();
            const publicPath = getPublicPath({
              config,
              isProd: isProd6,
              context: api.context
            });
            const jsPath = (0, import_shared29.getDistPath)(config, "js");
            const jsAsyncPath = (0, import_shared29.getDistPath)(config, "jsAsync");
            const jsFilename = (0, import_shared29.getFilename)(config, "js", isProd6);
            const isJsFilenameFn = typeof jsFilename === "function";
            chain.output.path(api.context.distPath).filename(
              isJsFilenameFn ? (...args) => {
                const name = jsFilename(...args);
                return import_node_path15.posix.join(jsPath, name);
              } : import_node_path15.posix.join(jsPath, jsFilename)
            ).chunkFilename(
              isJsFilenameFn ? (...args) => {
                const name = jsFilename(...args);
                return import_node_path15.posix.join(jsAsyncPath, name);
              } : import_node_path15.posix.join(jsAsyncPath, jsFilename)
            ).publicPath(publicPath).pathinfo(false).hashFunction("xxhash64");
            if (isServer) {
              const serverPath = (0, import_shared29.getDistPath)(config, "server");
              chain.output.path(import_node_path15.posix.join(api.context.distPath, serverPath)).filename("[name].js").chunkFilename("[name].js").library({
                ...chain.output.get("library") || {},
                type: "commonjs2"
              });
            }
            if (isServiceWorker) {
              const workerPath = (0, import_shared29.getDistPath)(config, "worker");
              const filename = import_node_path15.posix.join(workerPath, "[name].js");
              chain.output.filename(filename).chunkFilename(filename);
            }
            if (config.output.copy && api.context.bundlerType === "rspack") {
              const { copy } = config.output;
              const options = Array.isArray(copy) ? { patterns: copy } : copy;
              chain.plugin(CHAIN_ID3.PLUGIN.COPY).use(import_core5.rspack.CopyRspackPlugin, [options]);
            }
            if (isUseCssExtract(config, target)) {
              const extractPluginOptions = config.tools.cssExtract.pluginOptions;
              const cssPath = (0, import_shared29.getDistPath)(config, "css");
              const cssFilename = (0, import_shared29.getFilename)(config, "css", isProd6);
              const cssAsyncPath = (0, import_shared29.getDistPath)(config, "cssAsync");
              chain.plugin(CHAIN_ID3.PLUGIN.MINI_CSS_EXTRACT).use(getCssExtractPlugin(), [
                {
                  filename: import_node_path15.posix.join(cssPath, cssFilename),
                  chunkFilename: import_node_path15.posix.join(cssAsyncPath, cssFilename),
                  ...extractPluginOptions
                }
              ]);
            }
          }
        );
      }
    });
  }
});

// src/plugins/resolve.ts
var resolve_exports = {};
__export(resolve_exports, {
  pluginResolve: () => pluginResolve
});
function applyFullySpecified({
  chain,
  CHAIN_ID: CHAIN_ID3
}) {
  chain.module.rule(CHAIN_ID3.RULE.MJS).test(/\.m?js/).resolve.set("fullySpecified", false);
}
function applyExtensions({ chain }) {
  const extensions = [
    // most projects are using TypeScript, resolve .ts(x) files first to reduce resolve time.
    ".ts",
    ".tsx",
    ".js",
    ".jsx",
    ".mjs",
    ".json"
  ];
  chain.resolve.extensions.merge(extensions);
}
function applyAlias({
  chain,
  target,
  config,
  rootPath
}) {
  const { alias } = config.source;
  if (!alias) {
    return;
  }
  const mergedAlias = (0, import_shared30.reduceConfigsWithContext)({
    initial: {},
    config: alias,
    ctx: { target }
  });
  for (const name of Object.keys(mergedAlias)) {
    const values = (0, import_shared30.castArray)(mergedAlias[name]);
    const formattedValues = values.map((value) => {
      if (typeof value === "string" && value.startsWith(".")) {
        return ensureAbsolutePath(rootPath, value);
      }
      return value;
    });
    chain.resolve.alias.set(
      name,
      formattedValues.length === 1 ? formattedValues[0] : formattedValues
    );
  }
}
var import_shared30, pluginResolve;
var init_resolve = __esm({
  "src/plugins/resolve.ts"() {
    "use strict";
    import_shared30 = require("@rsbuild/shared");
    init_helpers();
    pluginResolve = () => ({
      name: "rsbuild:resolve",
      setup(api) {
        api.modifyBundlerChain({
          order: "pre",
          handler: (chain, { target, CHAIN_ID: CHAIN_ID3 }) => {
            const config = api.getNormalizedConfig();
            applyExtensions({ chain });
            applyAlias({
              chain,
              target,
              config,
              rootPath: api.context.rootPath
            });
            applyFullySpecified({ chain, config, CHAIN_ID: CHAIN_ID3 });
          }
        });
        api.modifyRspackConfig(async (rspackConfig) => {
          const isTsProject = Boolean(api.context.tsconfigPath);
          const config = api.getNormalizedConfig();
          rspackConfig.resolve ||= {};
          if (isTsProject && config.source.aliasStrategy === "prefer-tsconfig") {
            rspackConfig.resolve.tsConfigPath = api.context.tsconfigPath;
          }
        });
      }
    });
  }
});

// src/plugins/fileSize.ts
var fileSize_exports = {};
__export(fileSize_exports, {
  filterAsset: () => filterAsset,
  pluginFileSize: () => pluginFileSize
});
async function printHeader(longestFileLength, longestLabelLength) {
  const longestLengths = [longestFileLength, longestLabelLength];
  const headerRow = ["File", "Size", "Gzipped"].reduce((prev, cur, index) => {
    const length = longestLengths[index];
    let curLabel = cur;
    if (length) {
      curLabel = cur.length < length ? cur + " ".repeat(length - cur.length) : cur;
    }
    return `${prev + curLabel}    `;
  }, "  ");
  import_shared32.logger.log(import_shared32.color.bold(import_shared32.color.blue(headerRow)));
}
async function printFileSizes(config, stats, rootPath) {
  if (config.detail === false && config.total === false) {
    return;
  }
  const { default: gzipSize } = await import("@rsbuild/shared/gzip-size");
  const formatAsset = (asset, distPath, distFolder) => {
    const fileName = asset.name.split("?")[0];
    const contents = import_shared31.fse.readFileSync(import_node_path16.default.join(distPath, fileName));
    const size = contents.length;
    const gzippedSize = gzipSize.sync(contents);
    return {
      size,
      folder: import_node_path16.default.join(distFolder, import_node_path16.default.dirname(fileName)),
      name: import_node_path16.default.basename(fileName),
      gzippedSize,
      sizeLabel: calcFileSize(size),
      gzipSizeLabel: getAssetColor(gzippedSize)(calcFileSize(gzippedSize))
    };
  };
  const multiStats = "stats" in stats ? stats.stats : [stats];
  const assets = multiStats.map((stats2) => {
    const distPath = stats2.compilation.outputOptions.path;
    if (!distPath) {
      return [];
    }
    const origin = stats2.toJson({
      all: false,
      assets: true,
      // TODO: need supported in rspack
      // @ts-expect-error
      cachedAssets: true,
      groupAssetsByInfo: false,
      groupAssetsByPath: false,
      groupAssetsByChunk: false,
      groupAssetsByExtension: false,
      groupAssetsByEmitStatus: false
    });
    const filteredAssets = origin.assets.filter(
      (asset) => filterAsset(asset.name)
    );
    const distFolder = import_node_path16.default.relative(rootPath, distPath);
    return filteredAssets.map(
      (asset) => formatAsset(asset, distPath, distFolder)
    );
  }).reduce((single, all) => all.concat(single), []);
  if (assets.length === 0) {
    return;
  }
  assets.sort((a, b) => a.size - b.size);
  import_shared32.logger.info("Production file sizes:\n");
  const longestLabelLength = Math.max(...assets.map((a) => a.sizeLabel.length));
  const longestFileLength = Math.max(
    ...assets.map((a) => (a.folder + import_node_path16.default.sep + a.name).length)
  );
  if (config.detail !== false) {
    printHeader(longestFileLength, longestLabelLength);
  }
  let totalSize = 0;
  let totalGzipSize = 0;
  for (const asset of assets) {
    let { sizeLabel } = asset;
    const { name, folder, gzipSizeLabel } = asset;
    const fileNameLength = (folder + import_node_path16.default.sep + name).length;
    const sizeLength = sizeLabel.length;
    totalSize += asset.size;
    totalGzipSize += asset.gzippedSize;
    if (config.detail !== false) {
      if (sizeLength < longestLabelLength) {
        const rightPadding = " ".repeat(longestLabelLength - sizeLength);
        sizeLabel += rightPadding;
      }
      let fileNameLabel = import_shared32.color.dim(asset.folder + import_node_path16.default.sep) + coloringAssetName(asset.name);
      if (fileNameLength < longestFileLength) {
        const rightPadding = " ".repeat(longestFileLength - fileNameLength);
        fileNameLabel += rightPadding;
      }
      import_shared32.logger.log(`  ${fileNameLabel}    ${sizeLabel}    ${gzipSizeLabel}`);
    }
  }
  if (config.total !== false) {
    const totalSizeLabel = `${import_shared32.color.bold(
      import_shared32.color.blue("Total size:")
    )}  ${calcFileSize(totalSize)}`;
    const gzippedSizeLabel = `${import_shared32.color.bold(
      import_shared32.color.blue("Gzipped size:")
    )}  ${calcFileSize(totalGzipSize)}`;
    import_shared32.logger.log(`
  ${totalSizeLabel}
  ${gzippedSizeLabel}
`);
  }
}
var import_node_path16, import_shared31, import_shared32, filterAsset, getAssetColor, calcFileSize, coloringAssetName, pluginFileSize;
var init_fileSize = __esm({
  "src/plugins/fileSize.ts"() {
    "use strict";
    import_node_path16 = __toESM(require("path"));
    import_shared31 = require("@rsbuild/shared");
    import_shared32 = require("@rsbuild/shared");
    init_constants();
    filterAsset = (asset) => !/\.map$/.test(asset) && !/\.LICENSE\.txt$/.test(asset);
    getAssetColor = (size) => {
      if (size > 300 * 1e3) {
        return import_shared32.color.red;
      }
      if (size > 100 * 1e3) {
        return import_shared32.color.yellow;
      }
      return import_shared32.color.green;
    };
    calcFileSize = (len) => {
      const val = len / 1e3;
      return `${val.toFixed(val < 1 ? 2 : 1)} kB`;
    };
    coloringAssetName = (assetName) => {
      if (import_shared31.JS_REGEX.test(assetName)) {
        return import_shared32.color.cyan(assetName);
      }
      if (CSS_REGEX.test(assetName)) {
        return import_shared32.color.yellow(assetName);
      }
      if (HTML_REGEX.test(assetName)) {
        return import_shared32.color.green(assetName);
      }
      return import_shared32.color.magenta(assetName);
    };
    pluginFileSize = () => ({
      name: "rsbuild:file-size",
      setup(api) {
        api.onAfterBuild(async ({ stats }) => {
          const { printFileSize } = api.getNormalizedConfig().performance;
          if (printFileSize === false) {
            return;
          }
          const printFileSizeConfig = typeof printFileSize === "boolean" ? {
            total: true,
            detail: true
          } : printFileSize;
          if (stats) {
            try {
              await printFileSizes(
                printFileSizeConfig,
                stats,
                api.context.rootPath
              );
            } catch (err) {
              import_shared32.logger.warn("Failed to print file size.");
              import_shared32.logger.warn(err);
            }
          }
        });
      }
    });
  }
});

// src/plugins/cleanOutput.ts
var cleanOutput_exports = {};
__export(cleanOutput_exports, {
  pluginCleanOutput: () => pluginCleanOutput
});
var import_node_path17, import_shared33, emptyDir, addTrailingSep, isStrictSubdir, pluginCleanOutput;
var init_cleanOutput = __esm({
  "src/plugins/cleanOutput.ts"() {
    "use strict";
    import_node_path17 = require("path");
    import_shared33 = require("@rsbuild/shared");
    emptyDir = async (dir) => {
      if (await import_shared33.fse.pathExists(dir)) {
        await import_shared33.fse.emptyDir(dir);
      }
    };
    addTrailingSep = (dir) => dir.endsWith(import_node_path17.sep) ? dir : dir + import_node_path17.sep;
    isStrictSubdir = (parent, child) => {
      const parentDir = addTrailingSep(parent);
      const childDir = addTrailingSep(child);
      return parentDir !== childDir && childDir.startsWith(parentDir);
    };
    pluginCleanOutput = () => ({
      name: "rsbuild:clean-output",
      setup(api) {
        const clean = async () => {
          const { distPath, rootPath } = api.context;
          const config = api.getNormalizedConfig();
          let { cleanDistPath } = config.output;
          if (cleanDistPath === void 0) {
            cleanDistPath = isStrictSubdir(rootPath, distPath);
            if (!cleanDistPath) {
              import_shared33.logger.warn(
                "The dist path is not a subdir of root path, Rsbuild will not empty it."
              );
              import_shared33.logger.warn(
                `Please set ${import_shared33.color.yellow("`output.cleanDistPath`")} config manually.`
              );
              import_shared33.logger.warn(`Current root path: ${import_shared33.color.dim(rootPath)}`);
              import_shared33.logger.warn(`Current dist path: ${import_shared33.color.dim(distPath)}`);
            }
          }
          if (cleanDistPath) {
            await emptyDir(distPath);
          }
        };
        api.onBeforeBuild(clean);
        api.onBeforeStartDevServer(clean);
      }
    });
  }
});

// src/plugins/asset.ts
var asset_exports = {};
__export(asset_exports, {
  getRegExpForExts: () => getRegExpForExts,
  pluginAsset: () => pluginAsset
});
function getRegExpForExts(exts) {
  const matcher = exts.map((ext) => ext.trim()).map((ext) => ext.startsWith(".") ? ext.slice(1) : ext).join("|");
  return new RegExp(
    exts.length === 1 ? `\\.${matcher}$` : `\\.(?:${matcher})$`,
    "i"
  );
}
var import_node_path18, import_shared34, chainStaticAssetRule, pluginAsset;
var init_asset = __esm({
  "src/plugins/asset.ts"() {
    "use strict";
    import_node_path18 = __toESM(require("path"));
    import_shared34 = require("@rsbuild/shared");
    init_constants();
    chainStaticAssetRule = ({
      emit,
      rule,
      maxSize,
      filename,
      assetType
    }) => {
      const generatorOptions = {
        filename
      };
      if (emit === false) {
        generatorOptions.emit = false;
      }
      rule.oneOf(`${assetType}-asset-url`).type("asset/resource").resourceQuery(/(__inline=false|url)/).set("generator", generatorOptions);
      rule.oneOf(`${assetType}-asset-inline`).type("asset/inline").resourceQuery(/inline/);
      rule.oneOf(`${assetType}-asset`).type("asset").parser({
        dataUrlCondition: {
          maxSize
        }
      }).set("generator", generatorOptions);
    };
    pluginAsset = () => ({
      name: "rsbuild:asset",
      setup(api) {
        api.modifyBundlerChain((chain, { isProd: isProd6, target }) => {
          const config = api.getNormalizedConfig();
          const createAssetRule = (assetType, exts, emit2) => {
            const regExp = getRegExpForExts(exts);
            const distDir = (0, import_shared34.getDistPath)(config, assetType);
            const filename = (0, import_shared34.getFilename)(config, assetType, isProd6);
            const { dataUriLimit } = config.output;
            const maxSize = typeof dataUriLimit === "number" ? dataUriLimit : dataUriLimit[assetType];
            const rule = chain.module.rule(assetType).test(regExp);
            chainStaticAssetRule({
              emit: emit2,
              rule,
              maxSize,
              filename: import_node_path18.default.posix.join(distDir, filename),
              assetType
            });
          };
          const emit = config.output.emitAssets({ target });
          createAssetRule("image", IMAGE_EXTENSIONS, emit);
          createAssetRule("svg", ["svg"], emit);
          createAssetRule(
            "media",
            [...VIDEO_EXTENSIONS, ...AUDIO_EXTENSIONS],
            emit
          );
          createAssetRule("font", FONT_EXTENSIONS, emit);
        });
      }
    });
  }
});

// src/plugins/minimize.ts
var minimize_exports = {};
__export(minimize_exports, {
  getSwcMinimizerOptions: () => getSwcMinimizerOptions,
  parseMinifyOptions: () => parseMinifyOptions,
  pluginMinimize: () => pluginMinimize
});
var import_shared35, import_core6, getSwcMinimizerOptions, parseMinifyOptions, pluginMinimize;
var init_minimize = __esm({
  "src/plugins/minimize.ts"() {
    "use strict";
    import_shared35 = require("@rsbuild/shared");
    import_core6 = require("@rspack/core");
    getSwcMinimizerOptions = (config) => {
      const options = {};
      const { removeConsole } = config.performance;
      if (removeConsole === true) {
        options.compress = {
          ...(0, import_shared35.isObject)(options.compress) ? options.compress : {},
          drop_console: true
        };
      } else if (Array.isArray(removeConsole)) {
        const pureFuncs = removeConsole.map((method) => `console.${method}`);
        options.compress = {
          ...(0, import_shared35.isObject)(options.compress) ? options.compress : {},
          pure_funcs: pureFuncs
        };
      }
      options.format ||= {};
      switch (config.output.legalComments) {
        case "inline":
          options.format.comments = "some";
          options.extractComments = false;
          break;
        case "linked":
          options.extractComments = true;
          break;
        case "none":
          options.format.comments = false;
          options.extractComments = false;
          break;
        default:
          break;
      }
      options.format.asciiOnly = config.output.charset === "ascii";
      const jsOptions = parseMinifyOptions(config).jsOptions;
      if (jsOptions) {
        return (0, import_shared35.deepmerge)(options, jsOptions);
      }
      return options;
    };
    parseMinifyOptions = (config, isProd6 = true) => {
      const minify = config.output.minify;
      if (minify === false || !isProd6) {
        return {
          minifyJs: false,
          minifyCss: false,
          minifyHtml: false,
          jsOptions: void 0,
          htmlOptions: void 0
        };
      }
      if (minify === true) {
        return {
          minifyJs: true,
          minifyCss: true,
          minifyHtml: true,
          jsOptions: void 0,
          htmlOptions: void 0
        };
      }
      return {
        minifyJs: minify.js !== false,
        minifyCss: minify.css !== false,
        minifyHtml: minify.html !== false,
        jsOptions: minify.jsOptions,
        htmlOptions: minify.htmlOptions
      };
    };
    pluginMinimize = () => ({
      name: "rsbuild:minimize",
      setup(api) {
        if (api.context.bundlerType === "webpack") {
          return;
        }
        api.modifyBundlerChain(async (chain, { isProd: isProd6 }) => {
          const config = api.getNormalizedConfig();
          const isMinimize = isProd6 && config.output.minify !== false;
          if (!isMinimize) {
            return;
          }
          const { SwcJsMinimizerRspackPlugin, SwcCssMinimizerRspackPlugin } = import_core6.rspack;
          const { minifyJs, minifyCss } = parseMinifyOptions(config);
          if (minifyJs) {
            chain.optimization.minimizer(import_shared35.CHAIN_ID.MINIMIZER.JS).use(SwcJsMinimizerRspackPlugin, [getSwcMinimizerOptions(config)]).end();
          }
          if (minifyCss) {
            chain.optimization.minimizer(import_shared35.CHAIN_ID.MINIMIZER.CSS).use(SwcCssMinimizerRspackPlugin, []).end();
          }
        });
      }
    });
  }
});

// src/rspack/HtmlBasicPlugin.ts
var HtmlBasicPlugin_exports = {};
__export(HtmlBasicPlugin_exports, {
  FILE_ATTRS: () => FILE_ATTRS,
  HEAD_TAGS: () => HEAD_TAGS,
  HtmlBasicPlugin: () => HtmlBasicPlugin,
  VOID_TAGS: () => VOID_TAGS,
  hasTitle: () => hasTitle
});
var import_shared36, VOID_TAGS, HEAD_TAGS, FILE_ATTRS, hasTitle, getTagPriority, formatBasicTag, fromBasicTag, formatTags, applyTagConfig, addTitleTag, addFavicon, HtmlBasicPlugin;
var init_HtmlBasicPlugin = __esm({
  "src/rspack/HtmlBasicPlugin.ts"() {
    "use strict";
    import_shared36 = require("@rsbuild/shared");
    init_pluginHelper();
    VOID_TAGS = [
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ];
    HEAD_TAGS = [
      "title",
      "base",
      "link",
      "style",
      "meta",
      "script",
      "noscript",
      "template"
    ];
    FILE_ATTRS = {
      link: "href",
      script: "src"
    };
    hasTitle = (html) => html ? /<title/i.test(html) && /<\/title/i.test(html) : false;
    getTagPriority = (tag, tagConfig) => {
      const head = tag.head ?? HEAD_TAGS.includes(tag.tag);
      let priority = head ? -2 : 2;
      const append = tag.append ?? tagConfig.append;
      if (typeof append === "boolean") {
        priority += append ? 1 : -1;
      }
      return priority;
    };
    formatBasicTag = (tag) => ({
      tag: tag.tagName,
      attrs: tag.attributes,
      children: tag.innerHTML
    });
    fromBasicTag = (tag) => ({
      meta: {},
      tagName: tag.tag,
      attributes: tag.attrs ?? {},
      voidTag: VOID_TAGS.includes(tag.tag),
      innerHTML: tag.children
    });
    formatTags = (tags, override) => tags.map((tag) => ({
      ...formatBasicTag(tag),
      publicPath: false,
      ...override
    }));
    applyTagConfig = (data, tagConfig, compilationHash, entryName) => {
      if (!tagConfig.tags?.length) {
        return data;
      }
      const fromInjectTags = (tags2) => {
        const ret = [];
        for (const tag of tags2) {
          const attrs = { ...tag.attrs };
          const filenameTag = FILE_ATTRS[tag.tag];
          let filename = attrs[filenameTag];
          if (typeof filename === "string") {
            const optPublicPath = tag.publicPath ?? tagConfig.publicPath;
            if (typeof optPublicPath === "function") {
              filename = optPublicPath(filename, data.publicPath);
            } else if (typeof optPublicPath === "string") {
              filename = (0, import_shared36.withPublicPath)(filename, optPublicPath);
            } else if (optPublicPath !== false) {
              filename = (0, import_shared36.withPublicPath)(filename, data.publicPath);
            }
            const optHash = tag.hash ?? tagConfig.hash;
            if (typeof optHash === "function") {
              if (compilationHash.length) {
                filename = optHash(filename, compilationHash);
              }
            } else if (typeof optHash === "string") {
              if (optHash.length) {
                filename = `${filename}?${optHash}`;
              }
            } else if (optHash === true) {
              if (compilationHash.length) {
                filename = `${filename}?${compilationHash}`;
              }
            }
            attrs[filenameTag] = filename;
            tag.attrs = attrs;
          }
          ret.push(fromBasicTag(tag));
        }
        return ret;
      };
      let tags = [
        ...formatTags(data.headTags, { head: true }),
        ...formatTags(data.bodyTags, { head: false })
      ];
      const utils = {
        hash: compilationHash,
        entryName,
        outputName: data.outputName,
        publicPath: data.publicPath
      };
      for (const item of tagConfig.tags) {
        if ((0, import_shared36.isFunction)(item)) {
          tags = item(tags, utils) || tags;
        } else {
          tags.push(item);
        }
        tags = tags.sort(
          (tag1, tag2) => getTagPriority(tag1, tagConfig) - getTagPriority(tag2, tagConfig)
        );
      }
      const [headTags, bodyTags] = (0, import_shared36.partition)(
        tags,
        (tag) => tag.head ?? HEAD_TAGS.includes(tag.tag)
      );
      data.headTags = fromInjectTags(headTags);
      data.bodyTags = fromInjectTags(bodyTags);
      return data;
    };
    addTitleTag = (headTags, title = "") => {
      headTags.unshift({
        tagName: "title",
        innerHTML: title,
        attributes: {},
        voidTag: false,
        meta: {}
      });
    };
    addFavicon = (headTags, favicon) => {
      if (favicon) {
        headTags.unshift({
          tagName: "link",
          voidTag: true,
          attributes: {
            rel: "icon",
            href: favicon
          },
          meta: {}
        });
      }
    };
    HtmlBasicPlugin = class {
      constructor(options, modifyTagsFn) {
        __publicField(this, "name");
        __publicField(this, "options");
        __publicField(this, "modifyTagsFn");
        this.name = "HtmlBasicPlugin";
        this.options = options;
        this.modifyTagsFn = modifyTagsFn;
      }
      apply(compiler) {
        compiler.hooks.compilation.tap(this.name, (compilation) => {
          getHTMLPlugin().getHooks(compilation).alterAssetTagGroups.tapPromise(this.name, async (data) => {
            const entryName = data.plugin.options?.entryName;
            if (!entryName) {
              return data;
            }
            const { headTags, bodyTags } = data;
            const { favicon, tagConfig, templateContent } = this.options[entryName];
            if (!hasTitle(templateContent)) {
              addTitleTag(headTags, data.plugin.options?.title);
            }
            addFavicon(headTags, favicon);
            const tags = {
              headTags: headTags.map(formatBasicTag),
              bodyTags: bodyTags.map(formatBasicTag)
            };
            const modified = this.modifyTagsFn ? await this.modifyTagsFn(tags, {
              compilation,
              assetPrefix: data.publicPath,
              filename: data.outputName
            }) : tags;
            Object.assign(data, {
              headTags: modified.headTags.map(fromBasicTag),
              bodyTags: modified.bodyTags.map(fromBasicTag)
            });
            if (tagConfig) {
              const hash = compilation.hash ?? "";
              applyTagConfig(data, tagConfig, hash, entryName);
            }
            return data;
          });
        });
      }
    };
  }
});

// src/rspack/HtmlAppIconPlugin.ts
var HtmlAppIconPlugin_exports = {};
__export(HtmlAppIconPlugin_exports, {
  HtmlAppIconPlugin: () => HtmlAppIconPlugin
});
var import_node_fs4, import_node_path19, import_shared37, HtmlAppIconPlugin;
var init_HtmlAppIconPlugin = __esm({
  "src/rspack/HtmlAppIconPlugin.ts"() {
    "use strict";
    import_node_fs4 = __toESM(require("fs"));
    import_node_path19 = require("path");
    import_shared37 = require("@rsbuild/shared");
    init_pluginHelper();
    HtmlAppIconPlugin = class {
      constructor(options) {
        __publicField(this, "name");
        __publicField(this, "distDir");
        __publicField(this, "iconPath");
        this.name = "HtmlAppIconPlugin";
        this.distDir = options.distDir;
        this.iconPath = options.iconPath;
      }
      apply(compiler) {
        if (!import_node_fs4.default.existsSync(this.iconPath)) {
          throw new Error(
            `[${this.name}] Can not find the app icon, please check if the '${this.iconPath}' file exists'.`
          );
        }
        const iconRelativePath = import_node_path19.posix.join(this.distDir, (0, import_node_path19.basename)(this.iconPath));
        compiler.hooks.compilation.tap(this.name, (compilation) => {
          getHTMLPlugin().getHooks(compilation).alterAssetTagGroups.tap(this.name, (data) => {
            const publicPath = (0, import_shared37.getPublicPathFromCompiler)(compiler);
            data.headTags.unshift({
              tagName: "link",
              voidTag: true,
              attributes: {
                rel: "apple-touch-icon",
                sizes: "180*180",
                href: (0, import_shared37.withPublicPath)(iconRelativePath, publicPath)
              },
              meta: {}
            });
            return data;
          });
        });
        compiler.hooks.thisCompilation.tap(
          this.name,
          (compilation) => {
            compilation.hooks.processAssets.tap(
              {
                name: this.name,
                stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS
              },
              () => {
                const source = import_node_fs4.default.readFileSync(this.iconPath);
                compilation.emitAsset(
                  iconRelativePath,
                  new compiler.webpack.sources.RawSource(source, false)
                );
              }
            );
          }
        );
      }
    };
  }
});

// src/plugins/html.ts
var html_exports = {};
__export(html_exports, {
  getFavicon: () => getFavicon,
  getHtmlMinifyOptions: () => getHtmlMinifyOptions,
  getInject: () => getInject,
  getMetaTags: () => getMetaTags,
  getTemplate: () => getTemplate,
  getTitle: () => getTitle,
  pluginHtml: () => pluginHtml
});
function applyRemoveConsole(options, config) {
  const { removeConsole } = config.performance;
  const compressOptions = typeof options.compress === "boolean" ? {} : options.compress || {};
  if (removeConsole === true) {
    options.compress = {
      ...compressOptions,
      drop_console: true
    };
  } else if (Array.isArray(removeConsole)) {
    const pureFuncs = removeConsole.map((method) => `console.${method}`);
    options.compress = {
      ...compressOptions,
      pure_funcs: pureFuncs
    };
  }
  return options;
}
function getTerserMinifyOptions(config) {
  const options = {
    mangle: {
      safari10: true
    },
    format: {
      ascii_only: config.output.charset === "ascii"
    }
  };
  if (config.output.legalComments === "none") {
    options.format.comments = false;
  }
  const finalOptions = applyRemoveConsole(options, config);
  return finalOptions;
}
async function getHtmlMinifyOptions(isProd6, config) {
  if (!isProd6 || !config.output.minify || !parseMinifyOptions(config).minifyHtml) {
    return false;
  }
  const minifyJS = getTerserMinifyOptions(config);
  const htmlMinifyDefaultOptions = {
    removeComments: false,
    useShortDoctype: true,
    keepClosingSlash: true,
    collapseWhitespace: true,
    removeRedundantAttributes: true,
    removeScriptTypeAttributes: true,
    removeStyleLinkTypeAttributes: true,
    removeEmptyAttributes: true,
    minifyJS,
    minifyCSS: true,
    minifyURLs: true
  };
  const htmlMinifyOptions = parseMinifyOptions(config).htmlOptions;
  return typeof htmlMinifyOptions === "object" ? (0, import_shared38.deepmerge)(htmlMinifyDefaultOptions, htmlMinifyOptions) : htmlMinifyDefaultOptions;
}
function getTitle(entryName, config) {
  return (0, import_shared38.reduceConfigsMergeContext)({
    initial: "",
    config: config.html.title,
    ctx: { entryName }
  });
}
function getInject(entryName, config) {
  return (0, import_shared38.reduceConfigsMergeContext)({
    initial: "head",
    config: config.html.inject,
    ctx: { entryName }
  });
}
async function getTemplate(entryName, config, rootPath) {
  const DEFAULT_TEMPLATE = import_node_path20.default.resolve(STATIC_PATH, "template.html");
  const templatePath = (0, import_shared38.reduceConfigsMergeContext)({
    initial: DEFAULT_TEMPLATE,
    config: config.html.template,
    ctx: { entryName }
  });
  if (templatePath === DEFAULT_TEMPLATE) {
    return {
      templatePath
    };
  }
  const absolutePath = (0, import_node_path20.isAbsolute)(templatePath) ? templatePath : import_node_path20.default.resolve(rootPath, templatePath);
  if (!existTemplatePath.includes(absolutePath)) {
    if (!await isFileExists(absolutePath)) {
      throw new Error(
        `Failed to resolve HTML template, please check if the file exists: ${import_shared38.color.cyan(
          absolutePath
        )}`
      );
    }
    existTemplatePath.push(absolutePath);
  }
  const templateContent = await import_shared38.fse.readFile(absolutePath, "utf-8");
  return {
    templatePath: absolutePath,
    templateContent
  };
}
function getFavicon(entryName, config) {
  return (0, import_shared38.reduceConfigsMergeContext)({
    initial: "",
    config: config.html.favicon,
    ctx: { entryName }
  });
}
function getMetaTags(entryName, config, templateContent) {
  const metaTags = (0, import_shared38.reduceConfigsMergeContext)({
    initial: {},
    config: config.html.meta,
    ctx: { entryName }
  });
  if (templateContent && metaTags.charset) {
    const charsetRegExp = /<meta[^>]+charset=["'][^>]*>/i;
    if (charsetRegExp.test(templateContent)) {
      delete metaTags.charset;
    }
  }
  return metaTags;
}
function getTemplateParameters(entryName, config, assetPrefix) {
  return (compilation, assets, assetTags, pluginOptions) => {
    const { mountId, templateParameters } = config.html;
    const defaultOptions2 = {
      mountId,
      entryName,
      assetPrefix,
      compilation,
      webpackConfig: compilation.options,
      htmlWebpackPlugin: {
        tags: assetTags,
        files: assets,
        options: pluginOptions
      }
    };
    return (0, import_shared38.reduceConfigsWithContext)({
      initial: defaultOptions2,
      config: templateParameters,
      ctx: { entryName }
    });
  };
}
function getChunks(entryName, entryValue) {
  const chunks = [entryName];
  for (const item of entryValue) {
    if (!(0, import_shared38.isPlainObject)(item)) {
      continue;
    }
    const { dependOn } = item;
    if (!dependOn) {
      continue;
    }
    if (typeof dependOn === "string") {
      chunks.unshift(dependOn);
    } else {
      chunks.unshift(...dependOn);
    }
  }
  return chunks;
}
var import_node_path20, import_shared38, existTemplatePath, getTagConfig, pluginHtml;
var init_html = __esm({
  "src/plugins/html.ts"() {
    "use strict";
    import_node_path20 = __toESM(require("path"));
    import_shared38 = require("@rsbuild/shared");
    init_constants();
    init_helpers();
    init_minimize();
    existTemplatePath = [];
    getTagConfig = (api) => {
      const config = api.getNormalizedConfig();
      const tags = (0, import_shared38.castArray)(config.html.tags).filter(Boolean);
      if (!tags.length) {
        return void 0;
      }
      return {
        append: true,
        hash: false,
        publicPath: true,
        tags
      };
    };
    pluginHtml = (modifyTagsFn) => ({
      name: "rsbuild:html",
      setup(api) {
        api.modifyBundlerChain(
          async (chain, { HtmlPlugin, isProd: isProd6, CHAIN_ID: CHAIN_ID3, target }) => {
            const config = api.getNormalizedConfig();
            if ((0, import_shared38.isHtmlDisabled)(config, target)) {
              return;
            }
            const minify = await getHtmlMinifyOptions(isProd6, config);
            const assetPrefix = getPublicPathFromChain(chain, false);
            const entries = chain.entryPoints.entries() || {};
            const entryNames = Object.keys(entries);
            const htmlPaths = api.getHTMLPaths();
            const htmlInfoMap = {};
            const finalOptions = await Promise.all(
              entryNames.map(async (entryName) => {
                const entryValue = entries[entryName].values();
                const chunks = getChunks(entryName, entryValue);
                const inject = getInject(entryName, config);
                const filename = htmlPaths[entryName];
                const { templatePath, templateContent } = await getTemplate(
                  entryName,
                  config,
                  api.context.rootPath
                );
                const templateParameters = getTemplateParameters(
                  entryName,
                  config,
                  assetPrefix
                );
                const metaTags = getMetaTags(entryName, config, templateContent);
                const pluginOptions = {
                  meta: metaTags,
                  chunks,
                  inject,
                  minify,
                  filename,
                  template: templatePath,
                  entryName,
                  templateParameters,
                  scriptLoading: config.html.scriptLoading
                };
                if (chunks.length > 1) {
                  pluginOptions.chunksSortMode = "manual";
                }
                const htmlInfo = {};
                htmlInfoMap[entryName] = htmlInfo;
                if (templateContent) {
                  htmlInfo.templateContent = templateContent;
                }
                const tagConfig = getTagConfig(api);
                if (tagConfig) {
                  htmlInfo.tagConfig = tagConfig;
                }
                pluginOptions.title = getTitle(entryName, config);
                const favicon = getFavicon(entryName, config);
                if (favicon) {
                  if ((0, import_shared38.isURL)(favicon)) {
                    htmlInfo.favicon = favicon;
                  } else {
                    pluginOptions.favicon = favicon;
                  }
                }
                const finalOptions2 = (0, import_shared38.reduceConfigsWithContext)({
                  initial: pluginOptions,
                  config: typeof config.tools.htmlPlugin === "boolean" ? {} : config.tools.htmlPlugin,
                  ctx: { entryName, entryValue }
                });
                return finalOptions2;
              })
            );
            entryNames.forEach((entryName, index) => {
              chain.plugin(`${CHAIN_ID3.PLUGIN.HTML}-${entryName}`).use(HtmlPlugin, [finalOptions[index]]);
            });
            const { HtmlBasicPlugin: HtmlBasicPlugin2 } = await Promise.resolve().then(() => (init_HtmlBasicPlugin(), HtmlBasicPlugin_exports));
            chain.plugin(CHAIN_ID3.PLUGIN.HTML_BASIC).use(HtmlBasicPlugin2, [htmlInfoMap, modifyTagsFn]);
            if (config.html) {
              const { appIcon, crossorigin } = config.html;
              if (crossorigin) {
                const formattedCrossorigin = crossorigin === true ? "anonymous" : crossorigin;
                chain.output.crossOriginLoading(formattedCrossorigin);
              }
              if (appIcon) {
                const { HtmlAppIconPlugin: HtmlAppIconPlugin2 } = await Promise.resolve().then(() => (init_HtmlAppIconPlugin(), HtmlAppIconPlugin_exports));
                const distDir = (0, import_shared38.getDistPath)(config, "image");
                const iconPath = import_node_path20.default.isAbsolute(appIcon) ? appIcon : import_node_path20.default.join(api.context.rootPath, appIcon);
                chain.plugin(CHAIN_ID3.PLUGIN.APP_ICON).use(HtmlAppIconPlugin2, [{ iconPath, distDir }]);
              }
            }
          }
        );
        api.modifyHTMLTags({
          // ensure `crossorigin` and `nonce` can be applied to all tags
          order: "post",
          handler: ({ headTags, bodyTags }) => {
            const config = api.getNormalizedConfig();
            const { crossorigin } = config.html;
            const allTags = [...headTags, ...bodyTags];
            if (crossorigin) {
              const formattedCrossorigin = crossorigin === true ? "anonymous" : crossorigin;
              for (const tag of allTags) {
                if (tag.tag === "script" && tag.attrs?.src || tag.tag === "link" && tag.attrs?.rel === "stylesheet") {
                  tag.attrs.crossorigin ??= formattedCrossorigin;
                }
              }
            }
            return { headTags, bodyTags };
          }
        });
      }
    });
  }
});

// src/plugins/wasm.ts
var wasm_exports = {};
__export(wasm_exports, {
  pluginWasm: () => pluginWasm
});
var import_node_path21, import_shared39, pluginWasm;
var init_wasm = __esm({
  "src/plugins/wasm.ts"() {
    "use strict";
    import_node_path21 = require("path");
    import_shared39 = require("@rsbuild/shared");
    pluginWasm = () => ({
      name: "rsbuild:wasm",
      setup(api) {
        api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID3 }) => {
          const config = api.getNormalizedConfig();
          const distPath = (0, import_shared39.getDistPath)(config, "wasm");
          chain.experiments({
            ...chain.get("experiments"),
            asyncWebAssembly: true
          });
          const wasmFilename = import_node_path21.posix.join(distPath, "[hash].module.wasm");
          chain.output.merge({
            webassemblyModuleFilename: wasmFilename
          });
          chain.module.rule(CHAIN_ID3.RULE.WASM).test(/\.wasm$/).merge({
            dependency: "url"
          }).type("asset/resource").set("generator", {
            filename: wasmFilename
          });
        });
      }
    });
  }
});

// src/plugins/moment.ts
var moment_exports = {};
__export(moment_exports, {
  pluginMoment: () => pluginMoment
});
var pluginMoment;
var init_moment = __esm({
  "src/plugins/moment.ts"() {
    "use strict";
    pluginMoment = () => ({
      name: "rsbuild:moment",
      setup(api) {
        api.modifyBundlerChain(async (chain, { bundler }) => {
          const config = api.getNormalizedConfig();
          if (config.performance.removeMomentLocale) {
            chain.plugin("remove-moment-locale").use(bundler.IgnorePlugin, [
              {
                resourceRegExp: /^\.\/locale$/,
                contextRegExp: /moment$/
              }
            ]);
          }
        });
      }
    });
  }
});

// src/plugins/nodeAddons.ts
var nodeAddons_exports = {};
__export(nodeAddons_exports, {
  pluginNodeAddons: () => pluginNodeAddons
});
var import_node_path22, getFilename3, pluginNodeAddons;
var init_nodeAddons = __esm({
  "src/plugins/nodeAddons.ts"() {
    "use strict";
    import_node_path22 = __toESM(require("path"));
    getFilename3 = (resourcePath) => {
      let basename2 = "";
      if (resourcePath) {
        const parsed = import_node_path22.default.parse(resourcePath);
        if (parsed.dir) {
          basename2 = parsed.name;
        }
      }
      if (basename2) {
        return `${basename2}.node`;
      }
      return null;
    };
    pluginNodeAddons = () => ({
      name: "rsbuild:node-addons",
      setup(api) {
        api.transform(
          { test: /\.node$/, targets: ["node"], raw: true },
          ({ code, emitFile, resourcePath }) => {
            const name = getFilename3(resourcePath);
            if (name === null) {
              throw new Error(`Failed to load Node.js addon: "${resourcePath}"`);
            }
            emitFile(name, code);
            return `
try {
const path = require("path");
process.dlopen(module, path.join(__dirname, "${name}"));
} catch (error) {
throw new Error('Failed to load Node.js addon: "${name}"\\n' + error);
}
`;
          }
        );
      }
    });
  }
});

// src/plugins/define.ts
var define_exports = {};
__export(define_exports, {
  pluginDefine: () => pluginDefine
});
var import_shared40, pluginDefine;
var init_define = __esm({
  "src/plugins/define.ts"() {
    "use strict";
    import_shared40 = require("@rsbuild/shared");
    init_helpers();
    pluginDefine = () => ({
      name: "rsbuild:define",
      setup(api) {
        api.modifyBundlerChain((chain, { CHAIN_ID: CHAIN_ID3, bundler }) => {
          const config = api.getNormalizedConfig();
          const builtinVars = {
            "process.env.NODE_ENV": JSON.stringify((0, import_shared40.getNodeEnv)()),
            "process.env.ASSET_PREFIX": JSON.stringify(
              getPublicPathFromChain(chain, false)
            )
          };
          chain.plugin(CHAIN_ID3.PLUGIN.DEFINE).use(bundler.DefinePlugin, [
            { ...builtinVars, ...config.source.define }
          ]);
        });
      }
    });
  }
});

// src/plugins/progress.ts
var progress_exports = {};
__export(progress_exports, {
  pluginProgress: () => pluginProgress
});
var import_shared41, import_core7, pluginProgress;
var init_progress = __esm({
  "src/plugins/progress.ts"() {
    "use strict";
    import_shared41 = require("@rsbuild/shared");
    import_core7 = require("@rspack/core");
    pluginProgress = () => ({
      name: "rsbuild:progress",
      setup(api) {
        if (api.context.bundlerType === "webpack") {
          return;
        }
        api.modifyBundlerChain(async (chain, { target, CHAIN_ID: CHAIN_ID3 }) => {
          const config = api.getNormalizedConfig();
          const options = config.dev.progressBar ?? // enable progress bar in production by default
          (0, import_shared41.isProd)();
          if (!options) {
            return;
          }
          const prefix = options !== true && options.id !== void 0 ? options.id : import_shared41.TARGET_ID_MAP[target];
          chain.plugin(CHAIN_ID3.PLUGIN.PROGRESS).use(import_core7.rspack.ProgressPlugin, [
            {
              prefix,
              ...options === true ? {} : options
            }
          ]);
        });
      }
    });
  }
});

// src/plugins/swc.ts
var swc_exports = {};
__export(swc_exports, {
  applySwcDecoratorConfig: () => applySwcDecoratorConfig,
  pluginSwc: () => pluginSwc
});
async function getDefaultSwcConfig(config, rootPath, target) {
  return {
    jsc: {
      externalHelpers: true,
      parser: {
        tsx: false,
        syntax: "typescript",
        decorators: true
      },
      // Avoid the webpack magic comment to be removed
      // https://github.com/swc-project/swc/issues/6403
      preserveAllComments: true
    },
    isModule: "unknown",
    env: {
      targets: await (0, import_shared42.getBrowserslistWithDefault)(rootPath, config, target)
    }
  };
}
async function applyCoreJs(swcConfig, polyfillMode) {
  const coreJsPath = require.resolve("core-js/package.json");
  const version2 = (0, import_shared42.getCoreJsVersion)(coreJsPath);
  const coreJsDir = import_node_path23.default.dirname(coreJsPath);
  swcConfig.env.coreJs = version2;
  if (polyfillMode === "usage") {
    swcConfig.env.shippedProposals = true;
  }
  return coreJsDir;
}
function applyTransformImport(swcConfig, pluginImport) {
  if (pluginImport !== false && pluginImport) {
    swcConfig.rspackExperiments ??= {};
    swcConfig.rspackExperiments.import ??= [];
    swcConfig.rspackExperiments.import.push(...pluginImport);
  }
}
function applySwcDecoratorConfig(swcConfig, config) {
  swcConfig.jsc ||= {};
  swcConfig.jsc.transform ||= {};
  const { version: version2 } = config.source.decorators;
  switch (version2) {
    case "legacy":
      swcConfig.jsc.transform.legacyDecorator = true;
      swcConfig.jsc.transform.decoratorMetadata = true;
      swcConfig.jsc.transform.useDefineForClassFields = false;
      break;
    case "2022-03":
      swcConfig.jsc.transform.legacyDecorator = false;
      swcConfig.jsc.transform.decoratorVersion = "2022-03";
      break;
    default:
      throw new Error("Unknown decorators version: ${version}");
  }
}
var import_node_path23, import_shared42, builtinSwcLoaderName, pluginSwc;
var init_swc = __esm({
  "src/plugins/swc.ts"() {
    "use strict";
    import_node_path23 = __toESM(require("path"));
    import_shared42 = require("@rsbuild/shared");
    init_constants();
    builtinSwcLoaderName = "builtin:swc-loader";
    pluginSwc = () => ({
      name: PLUGIN_SWC_NAME,
      setup(api) {
        if (api.context.bundlerType === "webpack") {
          return;
        }
        api.modifyBundlerChain({
          order: "pre",
          handler: async (chain, { CHAIN_ID: CHAIN_ID3, target }) => {
            const config = api.getNormalizedConfig();
            const rule = chain.module.rule(CHAIN_ID3.RULE.JS).test(import_shared42.SCRIPT_REGEX).type("javascript/auto");
            const dataUriRule = chain.module.rule(CHAIN_ID3.RULE.JS_DATA_URI).mimetype({
              or: ["text/javascript", "application/javascript"]
            });
            (0, import_shared42.applyScriptCondition)({
              rule,
              chain,
              config,
              context: api.context,
              includes: [],
              excludes: []
            });
            const swcConfig = await getDefaultSwcConfig(
              config,
              api.context.rootPath,
              target
            );
            applyTransformImport(swcConfig, config.source.transformImport);
            applySwcDecoratorConfig(swcConfig, config);
            if (swcConfig.jsc?.externalHelpers) {
              chain.resolve.alias.set(
                "@swc/helpers",
                import_node_path23.default.dirname(require.resolve("@swc/helpers/package.json"))
              );
            }
            if ((0, import_shared42.isWebTarget)(target)) {
              const polyfillMode = config.output.polyfill;
              if (polyfillMode === "off") {
                swcConfig.env.mode = void 0;
              } else {
                swcConfig.env.mode = polyfillMode;
                const coreJsDir = await applyCoreJs(swcConfig, polyfillMode);
                for (const item of [rule, dataUriRule]) {
                  item.resolve.alias.set("core-js", coreJsDir);
                }
              }
            }
            const mergedSwcConfig = (0, import_shared42.reduceConfigs)({
              initial: swcConfig,
              config: config.tools.swc,
              mergeFn: import_shared42.deepmerge
            });
            rule.use(CHAIN_ID3.USE.SWC).loader(builtinSwcLoaderName).options(mergedSwcConfig);
            dataUriRule.resolve.set("fullySpecified", false).end().use(CHAIN_ID3.USE.SWC).loader(builtinSwcLoaderName).options((0, import_shared42.cloneDeep)(mergedSwcConfig));
          }
        });
      }
    });
  }
});

// src/plugins/externals.ts
var externals_exports = {};
__export(externals_exports, {
  pluginExternals: () => pluginExternals
});
function pluginExternals() {
  return {
    name: "rsbuild:externals",
    setup(api) {
      api.modifyBundlerChain((chain) => {
        const { externals } = api.getNormalizedConfig().output;
        if (externals) {
          chain.externals(externals);
        }
      });
      api.onBeforeCreateCompiler(({ bundlerConfigs }) => {
        for (const config of bundlerConfigs) {
          const isWebWorker = Array.isArray(config.target) ? config.target.includes("webworker") : config.target === "webworker";
          if (isWebWorker && config.externals) {
            delete config.externals;
          }
        }
      });
    }
  };
}
var init_externals = __esm({
  "src/plugins/externals.ts"() {
    "use strict";
  }
});

// src/plugins/splitChunks.ts
var splitChunks_exports = {};
__export(splitChunks_exports, {
  MODULE_PATH_REGEX: () => MODULE_PATH_REGEX,
  getPackageNameFromModulePath: () => getPackageNameFromModulePath,
  pluginSplitChunks: () => pluginSplitChunks
});
function getUserDefinedCacheGroups(forceSplitting) {
  const cacheGroups = {};
  const pairs = Array.isArray(forceSplitting) ? forceSplitting.map(
    (regexp, index) => [`force-split-${index}`, regexp]
  ) : Object.entries(forceSplitting);
  for (const [key, regexp] of pairs) {
    cacheGroups[key] = {
      test: regexp,
      name: key,
      chunks: "all",
      // Ignore minimum size, minimum chunks and maximum requests and always create chunks for user defined cache group.
      enforce: true
    };
  }
  return cacheGroups;
}
function splitByExperience(ctx) {
  const { override, polyfill, defaultConfig, userDefinedCacheGroups } = ctx;
  const experienceCacheGroup = {};
  const packageRegExps = {
    lodash: (0, import_shared43.createDependenciesRegExp)("lodash", "lodash-es"),
    axios: (0, import_shared43.createDependenciesRegExp)("axios", /axios-.+/)
  };
  if (polyfill === "entry" || polyfill === "usage") {
    packageRegExps.polyfill = (0, import_shared43.createDependenciesRegExp)(
      "tslib",
      "core-js",
      "@babel/runtime",
      "@swc/helpers"
    );
  }
  for (const [name, test] of Object.entries(packageRegExps)) {
    const key = `lib-${name}`;
    experienceCacheGroup[key] = {
      test,
      priority: 0,
      name: key,
      reuseExistingChunk: true
    };
  }
  return {
    ...defaultConfig,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...experienceCacheGroup,
      ...userDefinedCacheGroups,
      ...override.cacheGroups
    }
  };
}
function getPackageNameFromModulePath(modulePath) {
  const handleModuleContext = modulePath?.match(MODULE_PATH_REGEX);
  if (!handleModuleContext) {
    return void 0;
  }
  const [, scope, name] = handleModuleContext;
  const packageName = ["npm", (scope ?? "").replace("@", ""), name].filter(Boolean).join(".");
  return packageName;
}
function splitByModule(ctx) {
  const { override, userDefinedCacheGroups, defaultConfig } = ctx;
  return {
    ...defaultConfig,
    minSize: 0,
    maxInitialRequests: Number.POSITIVE_INFINITY,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...userDefinedCacheGroups,
      // Core group
      vendors: {
        priority: -9,
        test: import_shared43.NODE_MODULES_REGEX,
        name(module2) {
          return module2 ? getPackageNameFromModulePath(module2.context) : void 0;
        }
      },
      ...override.cacheGroups
    }
  };
}
function splitBySize(ctx) {
  const { override, userDefinedCacheGroups, defaultConfig, userConfig } = ctx;
  (0, import_node_assert.default)(userConfig.strategy === "split-by-size");
  return {
    ...defaultConfig,
    minSize: userConfig.minSize ?? 0,
    maxSize: userConfig.maxSize ?? Number.POSITIVE_INFINITY,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...userDefinedCacheGroups,
      ...override.cacheGroups
    }
  };
}
function splitCustom(ctx) {
  const { override, userDefinedCacheGroups, defaultConfig } = ctx;
  return {
    ...defaultConfig,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...userDefinedCacheGroups,
      ...override.cacheGroups
    }
  };
}
function allInOne(_ctx) {
  return false;
}
function singleVendor(ctx) {
  const { override, defaultConfig, userDefinedCacheGroups } = ctx;
  const singleVendorCacheGroup = {
    singleVendor: {
      test: import_shared43.NODE_MODULES_REGEX,
      priority: 0,
      chunks: "all",
      name: "vendor",
      enforce: true,
      reuseExistingChunk: true
    }
  };
  return {
    ...defaultConfig,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...singleVendorCacheGroup,
      ...userDefinedCacheGroups,
      ...override.cacheGroups
    }
  };
}
var import_node_assert, import_shared43, MODULE_PATH_REGEX, SPLIT_STRATEGY_DISPATCHER, pluginSplitChunks;
var init_splitChunks = __esm({
  "src/plugins/splitChunks.ts"() {
    "use strict";
    import_node_assert = __toESM(require("assert"));
    import_shared43 = require("@rsbuild/shared");
    MODULE_PATH_REGEX = /.*[\\/]node_modules[\\/](?!\.pnpm[\\/])(?:(@[^\\/]+)[\\/])?([^\\/]+)/;
    SPLIT_STRATEGY_DISPATCHER = {
      "split-by-experience": splitByExperience,
      "split-by-module": splitByModule,
      "split-by-size": splitBySize,
      custom: splitCustom,
      "all-in-one": allInOne,
      "single-vendor": singleVendor
    };
    pluginSplitChunks = () => ({
      name: "rsbuild:split-chunks",
      setup(api) {
        api.modifyBundlerChain(
          async (chain, { isServer, isWebWorker, isServiceWorker }) => {
            if (isServer || isWebWorker || isServiceWorker) {
              chain.optimization.splitChunks(false);
              if (isWebWorker || isServiceWorker) {
                chain.module.parser.merge({
                  javascript: {
                    dynamicImportMode: "eager"
                  }
                });
              }
              return;
            }
            const config = api.getNormalizedConfig();
            const defaultConfig = {
              // Optimize both `initial` and `async` chunks
              chunks: "all",
              // When chunk size >= 50000 bytes, split it into separate chunk
              // @ts-expect-error Rspack type missing
              enforceSizeThreshold: 5e4,
              cacheGroups: {}
            };
            const { chunkSplit } = config.performance;
            let userDefinedCacheGroups = {};
            if (chunkSplit.forceSplitting) {
              userDefinedCacheGroups = getUserDefinedCacheGroups(
                chunkSplit.forceSplitting
              );
            }
            const override = chunkSplit.strategy === "custom" ? chunkSplit.splitChunks ?? chunkSplit.override : chunkSplit.override;
            const splitChunksOptions = await SPLIT_STRATEGY_DISPATCHER[chunkSplit.strategy || "split-by-experience"]({
              defaultConfig,
              override: override || {},
              userDefinedCacheGroups,
              userConfig: chunkSplit,
              rootPath: api.context.rootPath,
              polyfill: config.output.polyfill
            });
            chain.optimization.splitChunks(splitChunksOptions);
          }
        );
      }
    });
  }
});

// src/plugins/open.ts
var open_exports = {};
__export(open_exports, {
  openBrowser: () => openBrowser,
  pluginOpen: () => pluginOpen,
  replacePlaceholder: () => replacePlaceholder,
  resolveUrl: () => resolveUrl
});
async function openBrowser(url2) {
  const shouldTryOpenChromeWithAppleScript = process.platform === "darwin";
  if (shouldTryOpenChromeWithAppleScript) {
    try {
      const targetBrowser = await getTargetBrowser();
      if (targetBrowser) {
        await execAsync(
          `osascript openChrome.applescript "${encodeURI(
            url2
          )}" "${targetBrowser}"`,
          {
            cwd: STATIC_PATH
          }
        );
        return true;
      }
      (0, import_shared44.debug)("Failed to find the target browser.");
    } catch (err) {
      (0, import_shared44.debug)("Failed to open start URL with apple script.");
      import_shared44.logger.debug(err);
    }
  }
  try {
    const { default: open } = await import("../compiled/open/index.js");
    await open(url2);
    return true;
  } catch (err) {
    import_shared44.logger.error("Failed to open start URL.");
    import_shared44.logger.error(err);
    return false;
  }
}
function resolveUrl(str, base) {
  if ((0, import_shared44.canParse)(str)) {
    return str;
  }
  try {
    const url2 = new URL(str, base);
    return url2.href;
  } catch (e) {
    throw new Error(
      "[rsbuild:open]: Invalid input: not a valid URL or pathname"
    );
  }
}
function pluginOpen() {
  return {
    name: "rsbuild:open",
    setup(api) {
      const onStartServer = async (params) => {
        const { port, routes } = params;
        const config = api.getNormalizedConfig();
        const { https } = api.context.devServer || {};
        const { targets, before } = normalizeOpenConfig(config);
        const isCodesandbox = process.env.CSB === "true";
        const shouldOpen = targets !== void 0 && !isCodesandbox;
        if (!shouldOpen) {
          return;
        }
        const urls = [];
        const protocol = https ? "https" : "http";
        const baseUrl = `${protocol}://localhost:${port}`;
        if (!targets.length) {
          if (routes.length) {
            urls.push(`${baseUrl}${routes[0].pathname}`);
          }
        } else {
          urls.push(
            ...targets.map(
              (target) => resolveUrl(replacePlaceholder(target, port), baseUrl)
            )
          );
        }
        const openUrls = () => {
          for (const url2 of urls) {
            if (!openedURLs.includes(url2)) {
              openBrowser(url2);
              openedURLs.push(url2);
            }
          }
        };
        if (before) {
          await before();
        }
        openUrls();
      };
      api.onAfterStartDevServer(onStartServer);
      api.onAfterStartProdServer(onStartServer);
    }
  };
}
var import_node_child_process, import_node_util, import_shared44, execAsync, supportedChromiumBrowsers, getTargetBrowser, replacePlaceholder, openedURLs, normalizeOpenConfig;
var init_open = __esm({
  "src/plugins/open.ts"() {
    "use strict";
    import_node_child_process = require("child_process");
    import_node_util = require("util");
    import_shared44 = require("@rsbuild/shared");
    init_constants();
    execAsync = (0, import_node_util.promisify)(import_node_child_process.exec);
    supportedChromiumBrowsers = [
      "Google Chrome Canary",
      "Google Chrome Dev",
      "Google Chrome Beta",
      "Google Chrome",
      "Microsoft Edge",
      "Brave Browser",
      "Vivaldi",
      "Chromium"
    ];
    getTargetBrowser = async () => {
      let targetBrowser = process.env.BROWSER;
      if (!targetBrowser || !supportedChromiumBrowsers.includes(targetBrowser)) {
        const { stdout: ps } = await execAsync("ps cax");
        targetBrowser = supportedChromiumBrowsers.find((b) => ps.includes(b));
      }
      return targetBrowser;
    };
    replacePlaceholder = (url2, port) => url2.replace(/<port>/g, String(port));
    openedURLs = [];
    normalizeOpenConfig = (config) => {
      const open = config.server.open || config.dev.startUrl;
      const { beforeStartUrl } = config.dev;
      if (open === false) {
        return {};
      }
      if (open === true) {
        return { targets: [], before: beforeStartUrl };
      }
      if (typeof open === "string") {
        return { targets: [open], before: beforeStartUrl };
      }
      if (Array.isArray(open)) {
        return { targets: open, before: beforeStartUrl };
      }
      return {
        targets: open.target ? (0, import_shared44.castArray)(open.target) : [],
        before: open.before
      };
    };
  }
});

// src/rspack/InlineChunkHtmlPlugin.ts
var InlineChunkHtmlPlugin_exports = {};
__export(InlineChunkHtmlPlugin_exports, {
  InlineChunkHtmlPlugin: () => InlineChunkHtmlPlugin
});
var import_node_path24, import_shared45, InlineChunkHtmlPlugin;
var init_InlineChunkHtmlPlugin = __esm({
  "src/rspack/InlineChunkHtmlPlugin.ts"() {
    "use strict";
    import_node_path24 = require("path");
    import_shared45 = require("@rsbuild/shared");
    init_pluginHelper();
    InlineChunkHtmlPlugin = class {
      constructor({
        styleTests,
        scriptTests,
        distPath
      }) {
        __publicField(this, "name");
        __publicField(this, "styleTests");
        __publicField(this, "scriptTests");
        __publicField(this, "distPath");
        __publicField(this, "inlinedAssets");
        this.name = "InlineChunkHtmlPlugin";
        this.styleTests = styleTests;
        this.scriptTests = scriptTests;
        this.distPath = distPath;
        this.inlinedAssets = /* @__PURE__ */ new Set();
      }
      /**
       * If we inlined the chunk to HTML,we should update the value of sourceMappingURL,
       * because the relative path of source code has been changed.
       * @param source
       */
      updateSourceMappingURL({
        source,
        compilation,
        publicPath,
        type
      }) {
        const { devtool } = compilation.options;
        if (devtool && // If the source map is inlined, we do not need to update the sourceMappingURL
        !devtool.includes("inline") && source.includes("# sourceMappingURL")) {
          const prefix = (0, import_shared45.addTrailingSlash)(
            (0, import_node_path24.join)(publicPath, this.distPath[type] || "")
          );
          return source.replace(
            /# sourceMappingURL=/,
            `# sourceMappingURL=${prefix}`
          );
        }
        return source;
      }
      matchTests(name, source, tests) {
        return tests.some((test) => {
          if ((0, import_shared45.isFunction)(test)) {
            const size = source.length;
            return test({ name, size });
          }
          return test.exec(name);
        });
      }
      getInlinedScriptTag(publicPath, tag, compilation) {
        const { assets } = compilation;
        if (!(tag?.attributes.src && typeof tag.attributes.src === "string")) {
          return tag;
        }
        const { src, ...otherAttrs } = tag.attributes;
        const scriptName = publicPath ? src.replace(publicPath, "") : src;
        const asset = assets[scriptName];
        if (asset == null) {
          return tag;
        }
        const source = asset.source().toString();
        const shouldInline = this.matchTests(scriptName, source, this.scriptTests);
        if (!shouldInline) {
          return tag;
        }
        const ret = {
          tagName: "script",
          innerHTML: this.updateSourceMappingURL({
            source,
            compilation,
            publicPath,
            type: "js"
          }),
          attributes: {
            ...otherAttrs
          },
          closeTag: true
        };
        this.inlinedAssets.add(scriptName);
        return ret;
      }
      getInlinedCSSTag(publicPath, tag, compilation) {
        const { assets } = compilation;
        if (!(tag.attributes.href && typeof tag.attributes.href === "string")) {
          return tag;
        }
        const linkName = publicPath ? tag.attributes.href.replace(publicPath, "") : tag.attributes.href;
        const asset = assets[linkName];
        if (asset == null) {
          return tag;
        }
        const source = asset.source().toString();
        const shouldInline = this.matchTests(linkName, source, this.styleTests);
        if (!shouldInline) {
          return tag;
        }
        const ret = {
          tagName: "style",
          innerHTML: this.updateSourceMappingURL({
            source,
            compilation,
            publicPath,
            type: "css"
          }),
          closeTag: true
        };
        this.inlinedAssets.add(linkName);
        return ret;
      }
      getInlinedTag(publicPath, tag, compilation) {
        if (tag.tagName === "script") {
          return this.getInlinedScriptTag(
            publicPath,
            tag,
            compilation
          );
        }
        if (tag.tagName === "link" && tag.attributes && tag.attributes.rel === "stylesheet") {
          return this.getInlinedCSSTag(
            publicPath,
            tag,
            compilation
          );
        }
        return tag;
      }
      apply(compiler) {
        compiler.hooks.compilation.tap(this.name, (compilation) => {
          const publicPath = (0, import_shared45.getPublicPathFromCompiler)(compiler);
          const tagFunction = (tag) => this.getInlinedTag(publicPath, tag, compilation);
          const hooks = getHTMLPlugin().getHooks(compilation);
          hooks.alterAssetTagGroups.tap(this.name, (assets) => {
            assets.headTags = assets.headTags.map(tagFunction);
            assets.bodyTags = assets.bodyTags.map(tagFunction);
            return assets;
          });
          compilation.hooks.processAssets.tap(
            {
              name: "InlineChunkHtmlPlugin",
              /**
               * Remove marked inline assets in summarize stage,
               * which should be later than the emitting of html-webpack-plugin
               */
              stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE
            },
            () => {
              const { devtool } = compiler.options;
              for (const name of this.inlinedAssets) {
                if (devtool === "hidden-source-map") {
                  compilation.deleteAsset(name);
                } else {
                  delete compilation.assets[name];
                }
              }
              this.inlinedAssets.clear();
            }
          );
        });
      }
    };
  }
});

// src/plugins/inlineChunk.ts
var inlineChunk_exports = {};
__export(inlineChunk_exports, {
  pluginInlineChunk: () => pluginInlineChunk
});
var import_shared46, pluginInlineChunk;
var init_inlineChunk = __esm({
  "src/plugins/inlineChunk.ts"() {
    "use strict";
    import_shared46 = require("@rsbuild/shared");
    init_constants();
    pluginInlineChunk = () => ({
      name: "rsbuild:inline-chunk",
      setup(api) {
        api.modifyBundlerChain(async (chain, { target, CHAIN_ID: CHAIN_ID3, isDev: isDev3 }) => {
          const config = api.getNormalizedConfig();
          if ((0, import_shared46.isHtmlDisabled)(config, target) || isDev3) {
            return;
          }
          const { InlineChunkHtmlPlugin: InlineChunkHtmlPlugin2 } = await Promise.resolve().then(() => (init_InlineChunkHtmlPlugin(), InlineChunkHtmlPlugin_exports));
          const { inlineStyles, inlineScripts } = config.output;
          const scriptTests = [];
          const styleTests = [];
          if (inlineScripts) {
            scriptTests.push(inlineScripts === true ? import_shared46.JS_REGEX : inlineScripts);
          }
          if (inlineStyles) {
            styleTests.push(inlineStyles === true ? CSS_REGEX : inlineStyles);
          }
          if (!scriptTests.length && !styleTests.length) {
            return;
          }
          chain.plugin(CHAIN_ID3.PLUGIN.INLINE_HTML).before(CHAIN_ID3.PLUGIN.HTML_BASIC).use(InlineChunkHtmlPlugin2, [
            {
              styleTests,
              scriptTests,
              distPath: (0, import_shared46.pick)(config.output.distPath, ["js", "css"])
            }
          ]);
        });
      }
    });
  }
});

// src/plugins/bundleAnalyzer.ts
var bundleAnalyzer_exports = {};
__export(bundleAnalyzer_exports, {
  pluginBundleAnalyzer: () => pluginBundleAnalyzer
});
function pluginBundleAnalyzer() {
  return {
    name: "rsbuild:bundle-analyzer",
    setup(api) {
      api.modifyRsbuildConfig((config) => {
        if ((0, import_shared47.isProd)() || !isUseAnalyzer(config)) {
          return;
        }
        config.dev ||= {};
        config.dev.writeToDisk = true;
        return config;
      });
      api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID3, target }) => {
        const config = api.getNormalizedConfig();
        if (!isUseAnalyzer(config)) {
          return;
        }
        const { default: BundleAnalyzer } = await import("@rsbuild/shared/webpack-bundle-analyzer");
        chain.plugin(CHAIN_ID3.PLUGIN.BUNDLE_ANALYZER).use(BundleAnalyzer.BundleAnalyzerPlugin, [
          {
            analyzerMode: "static",
            openAnalyzer: false,
            reportFilename: `report-${target}.html`,
            ...config.performance.bundleAnalyze || {}
          }
        ]);
      });
    }
  };
}
var import_shared47, isUseAnalyzer;
var init_bundleAnalyzer = __esm({
  "src/plugins/bundleAnalyzer.ts"() {
    "use strict";
    import_shared47 = require("@rsbuild/shared");
    isUseAnalyzer = (config) => process.env.BUNDLE_ANALYZE || config.performance?.bundleAnalyze;
  }
});

// src/plugins/rsdoctor.ts
var rsdoctor_exports = {};
__export(rsdoctor_exports, {
  pluginRsdoctor: () => pluginRsdoctor
});
var import_shared48, pluginRsdoctor;
var init_rsdoctor = __esm({
  "src/plugins/rsdoctor.ts"() {
    "use strict";
    import_shared48 = require("@rsbuild/shared");
    pluginRsdoctor = () => ({
      name: "rsbuild:rsdoctor",
      setup(api) {
        api.onBeforeCreateCompiler(async ({ bundlerConfigs }) => {
          if (process.env.RSDOCTOR !== "true") {
            return;
          }
          const isRspack = api.context.bundlerType === "rspack";
          const packageName = isRspack ? "@rsdoctor/rspack-plugin" : "@rsdoctor/webpack-plugin";
          let module2;
          try {
            const path13 = require.resolve(packageName, {
              paths: [api.context.rootPath]
            });
            module2 = await import(path13);
          } catch (err) {
            import_shared48.logger.warn(
              `\`process.env.RSDOCTOR\` enabled, please install ${import_shared48.color.bold(import_shared48.color.yellow(packageName))} package.`
            );
            return;
          }
          const pluginName = isRspack ? "RsdoctorRspackPlugin" : "RsdoctorWebpackPlugin";
          if (!module2 || !module2[pluginName]) {
            return;
          }
          let isAutoRegister = false;
          for (const config of bundlerConfigs) {
            const registered = config.plugins?.some(
              (plugin) => plugin?.constructor?.name === pluginName
            );
            if (registered) {
              return;
            }
            config.plugins ||= [];
            config.plugins.push(new module2[pluginName]());
            isAutoRegister = true;
          }
          if (isAutoRegister) {
            import_shared48.logger.info(`${import_shared48.color.bold(import_shared48.color.yellow(packageName))} enabled.`);
          }
        });
      }
    });
  }
});

// src/rspack/preload/helpers/extractChunks.ts
function isAsync(chunk) {
  if ("canBeInitial" in chunk) {
    return !chunk.canBeInitial();
  }
  if ("isInitial" in chunk) {
    return !chunk.isInitial();
  }
  return !chunk.initial;
}
function extractChunks({
  compilation,
  includeType
}) {
  const chunks = [...compilation.chunks];
  if (includeType === void 0 || includeType === "async-chunks") {
    return chunks.filter(isAsync);
  }
  if (includeType === "initial") {
    return chunks.filter((chunk) => !isAsync(chunk));
  }
  if (includeType === "all-chunks") {
    return chunks;
  }
  if (includeType === "all-assets") {
    const licenseAssets = [...compilation.assetsInfo?.values() || []].map((info) => {
      if (info.related?.license) {
        return info.related.license;
      }
      return false;
    }).filter(Boolean);
    return [
      {
        files: Object.keys(compilation.assets).filter(
          (t) => !licenseAssets.includes(t)
        )
      }
    ];
  }
  return chunks;
}
var init_extractChunks = __esm({
  "src/rspack/preload/helpers/extractChunks.ts"() {
    "use strict";
  }
});

// src/rspack/preload/helpers/determineAsValue.ts
function determineAsValue({
  href,
  file
}) {
  const url2 = new import_node_url3.URL(file || href, "https://example.com");
  const extension = import_node_path25.default.extname(url2.pathname).slice(1);
  if (["css"].includes(extension)) {
    return "style";
  }
  if (IMAGE_EXTENSIONS.includes(extension)) {
    return "image";
  }
  if (VIDEO_EXTENSIONS.includes(extension)) {
    return "video";
  }
  if (AUDIO_EXTENSIONS.includes(extension)) {
    return "audio";
  }
  if (FONT_EXTENSIONS.includes(extension)) {
    return "font";
  }
  if (["vtt"].includes(extension)) {
    return "track";
  }
  return "script";
}
var import_node_path25, import_node_url3;
var init_determineAsValue = __esm({
  "src/rspack/preload/helpers/determineAsValue.ts"() {
    "use strict";
    import_node_path25 = __toESM(require("path"));
    import_node_url3 = require("url");
    init_constants();
  }
});

// src/rspack/preload/helpers/doesChunkBelongToHtml.ts
function recursiveChunkGroup(chunkGroup) {
  const parents = chunkGroup.getParents();
  if (!parents.length) {
    return [chunkGroup.name];
  }
  return parents.flatMap((chunkParent) => recursiveChunkGroup(chunkParent));
}
function recursiveChunkEntryNames(chunk) {
  const isChunkName = (name) => Boolean(name);
  const [...chunkGroups] = chunk.groupsIterable;
  const names = chunkGroups.flatMap((chunkGroup) => recursiveChunkGroup(chunkGroup)).filter(isChunkName);
  return [...new Set(names)];
}
function isChunksFiltered(chunkName, includeChunks, excludeChunks) {
  if (Array.isArray(includeChunks) && includeChunks.indexOf(chunkName) === -1) {
    return false;
  }
  if (Array.isArray(excludeChunks) && excludeChunks.indexOf(chunkName) !== -1) {
    return false;
  }
  return true;
}
function doesChunkBelongToHtml({
  chunk,
  htmlPluginData
}) {
  const { options } = htmlPluginData.plugin;
  const chunkNames = recursiveChunkEntryNames(chunk);
  return chunkNames.some(
    (chunkName) => isChunksFiltered(chunkName, options?.chunks, options?.excludeChunks)
  );
}
var init_doesChunkBelongToHtml = __esm({
  "src/rspack/preload/helpers/doesChunkBelongToHtml.ts"() {
    "use strict";
  }
});

// src/rspack/preload/helpers/type.ts
var init_type = __esm({
  "src/rspack/preload/helpers/type.ts"() {
    "use strict";
  }
});

// src/rspack/preload/helpers/index.ts
var init_helpers2 = __esm({
  "src/rspack/preload/helpers/index.ts"() {
    "use strict";
    init_extractChunks();
    init_determineAsValue();
    init_doesChunkBelongToHtml();
    init_type();
  }
});

// src/rspack/preload/HtmlPreloadOrPrefetchPlugin.ts
var HtmlPreloadOrPrefetchPlugin_exports = {};
__export(HtmlPreloadOrPrefetchPlugin_exports, {
  HtmlPreloadOrPrefetchPlugin: () => HtmlPreloadOrPrefetchPlugin
});
function filterResourceHints(resourceHints, scripts) {
  return resourceHints.filter(
    (resourceHint) => !scripts.find(
      (script) => script.attributes.src === resourceHint.attributes.href
    )
  );
}
function generateLinks(options, type, compilation, htmlPluginData, HTMLCount) {
  const extractedChunks = extractChunks({
    compilation,
    includeType: options.type
  });
  const htmlChunks = (
    // Handle all chunks.
    options.type === "all-assets" || HTMLCount === 1 ? extractedChunks : (
      // Only handle chunks imported by this HtmlWebpackPlugin.
      extractedChunks.filter(
        (chunk) => doesChunkBelongToHtml({
          chunk,
          compilation,
          htmlPluginData,
          pluginOptions: options
        })
      )
    )
  );
  const allFiles = htmlChunks.reduce(
    (accumulated, chunk) => accumulated.concat([
      ...chunk.files,
      // sourcemap files are inside auxiliaryFiles in webpack5
      ...chunk.auxiliaryFiles || []
    ]),
    []
  );
  const uniqueFiles = new Set(allFiles);
  const filteredFiles = [...uniqueFiles].filter((file) => [/.map$/].every((regex) => !regex.test(file))).filter(
    (file) => !options.include || (typeof options.include === "function" ? options.include(file) : options.include.some((regex) => new RegExp(regex).test(file)))
  ).filter(
    (file) => !options.exclude || (typeof options.exclude === "function" ? !options.exclude(file) : options.exclude.every((regex) => !new RegExp(regex).test(file)))
  );
  const sortedFilteredFiles = filteredFiles.sort();
  const links = [];
  const publicPath = (0, import_shared49.getPublicPathFromCompiler)(compilation.compiler);
  const { crossOriginLoading } = compilation.compiler.options.output;
  for (const file of sortedFilteredFiles) {
    const href = (0, import_shared49.withPublicPath)(file, publicPath);
    const attributes = {
      href,
      rel: type
    };
    if (type === "preload") {
      attributes.as = determineAsValue({
        href,
        file
      });
      if (attributes.as === "font") {
        attributes.crossorigin = "";
      }
      if (attributes.as === "script" || attributes.as === "style") {
        if (crossOriginLoading && !(crossOriginLoading !== "use-credentials" && publicPath === "/")) {
          attributes.crossorigin = crossOriginLoading === "anonymous" ? "" : crossOriginLoading;
        }
      }
    }
    links.push({
      tagName: "link",
      attributes,
      voidTag: true,
      meta: {}
    });
  }
  return links;
}
var import_shared49, defaultOptions, HtmlPreloadOrPrefetchPlugin;
var init_HtmlPreloadOrPrefetchPlugin = __esm({
  "src/rspack/preload/HtmlPreloadOrPrefetchPlugin.ts"() {
    "use strict";
    import_shared49 = require("@rsbuild/shared");
    init_pluginHelper();
    init_helpers2();
    defaultOptions = {
      type: "async-chunks"
    };
    HtmlPreloadOrPrefetchPlugin = class {
      constructor(options, type, HTMLCount) {
        __publicField(this, "options");
        __publicField(this, "resourceHints", []);
        __publicField(this, "type");
        __publicField(this, "HTMLCount");
        this.options = {
          ...defaultOptions,
          ...typeof options === "boolean" ? {} : options
        };
        this.type = type;
        this.HTMLCount = HTMLCount;
      }
      apply(compiler) {
        compiler.hooks.compilation.tap(this.constructor.name, (compilation) => {
          getHTMLPlugin().getHooks(compilation).beforeAssetTagGeneration.tap(
            `HTML${(0, import_shared49.upperFirst)(this.type)}Plugin`,
            (htmlPluginData) => {
              this.resourceHints = generateLinks(
                this.options,
                this.type,
                compilation,
                htmlPluginData,
                this.HTMLCount
              );
              return htmlPluginData;
            }
          );
          getHTMLPlugin().getHooks(compilation).alterAssetTags.tap(
            `HTML${(0, import_shared49.upperFirst)(this.type)}Plugin`,
            (htmlPluginData) => {
              if (this.resourceHints) {
                htmlPluginData.assetTags.styles = [
                  ...filterResourceHints(
                    this.resourceHints,
                    htmlPluginData.assetTags.scripts
                  ),
                  ...htmlPluginData.assetTags.styles
                ];
              }
              return htmlPluginData;
            }
          );
        });
      }
    };
  }
});

// src/plugins/resourceHints.ts
var resourceHints_exports = {};
__export(resourceHints_exports, {
  pluginResourceHints: () => pluginResourceHints
});
var import_shared50, generateLinks2, pluginResourceHints;
var init_resourceHints = __esm({
  "src/plugins/resourceHints.ts"() {
    "use strict";
    import_shared50 = require("@rsbuild/shared");
    generateLinks2 = (options, rel) => options.map((option) => ({
      tag: "link",
      attrs: {
        rel,
        ...option
      }
    }));
    pluginResourceHints = () => ({
      name: "rsbuild:resource-hints",
      setup(api) {
        api.modifyHTMLTags(({ headTags, bodyTags }) => {
          const config = api.getNormalizedConfig();
          const { dnsPrefetch, preconnect } = config.performance;
          if (dnsPrefetch) {
            const attrs = dnsPrefetch.map((option) => ({ href: option }));
            if (attrs.length) {
              headTags.unshift(...generateLinks2(attrs, "dns-prefetch"));
            }
          }
          if (preconnect) {
            const attrs = preconnect.map(
              (option) => typeof option === "string" ? { href: option } : option
            );
            if (attrs.length) {
              headTags.unshift(...generateLinks2(attrs, "preconnect"));
            }
          }
          return { headTags, bodyTags };
        });
        api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID3, target }) => {
          const config = api.getNormalizedConfig();
          const {
            performance: { preload, prefetch }
          } = config;
          if ((0, import_shared50.isHtmlDisabled)(config, target)) {
            return;
          }
          const HTMLCount = chain.entryPoints.values().length;
          const { HtmlPreloadOrPrefetchPlugin: HtmlPreloadOrPrefetchPlugin2 } = await Promise.resolve().then(() => (init_HtmlPreloadOrPrefetchPlugin(), HtmlPreloadOrPrefetchPlugin_exports));
          if (prefetch) {
            chain.plugin(CHAIN_ID3.PLUGIN.HTML_PREFETCH).use(HtmlPreloadOrPrefetchPlugin2, [prefetch, "prefetch", HTMLCount]);
          }
          if (preload) {
            chain.plugin(CHAIN_ID3.PLUGIN.HTML_PRELOAD).use(HtmlPreloadOrPrefetchPlugin2, [preload, "preload", HTMLCount]);
          }
        });
      }
    });
  }
});

// src/plugins/performance.ts
var performance_exports = {};
__export(performance_exports, {
  pluginPerformance: () => pluginPerformance
});
var pluginPerformance;
var init_performance = __esm({
  "src/plugins/performance.ts"() {
    "use strict";
    pluginPerformance = () => ({
      name: "rsbuild:performance",
      setup(api) {
        api.modifyRsbuildConfig((rsbuildConfig) => {
          if (rsbuildConfig.performance?.profile) {
            if (!rsbuildConfig.performance?.bundleAnalyze) {
              rsbuildConfig.performance ??= {};
              rsbuildConfig.performance.bundleAnalyze = {
                analyzerMode: "disabled",
                generateStatsFile: true
              };
            } else {
              rsbuildConfig.performance.bundleAnalyze = {
                generateStatsFile: true,
                ...rsbuildConfig.performance.bundleAnalyze || {}
              };
            }
          }
        });
        api.modifyBundlerChain((chain) => {
          const config = api.getNormalizedConfig();
          const { profile } = config.performance;
          if (!profile) {
            return;
          }
          chain.profile(profile);
        });
      }
    });
  }
});

// src/plugins/server.ts
var server_exports = {};
__export(server_exports, {
  pluginServer: () => pluginServer
});
var import_node_path26, import_shared51, pluginServer;
var init_server = __esm({
  "src/plugins/server.ts"() {
    "use strict";
    import_node_path26 = require("path");
    import_shared51 = require("@rsbuild/shared");
    init_config();
    pluginServer = () => ({
      name: "rsbuild:server",
      setup(api) {
        api.onBeforeBuild(async () => {
          const config = api.getNormalizedConfig();
          const publicDirs = normalizePublicDirs(config.server.publicDir);
          for (const publicDir of publicDirs) {
            const { name, copyOnBuild } = publicDir;
            if (!copyOnBuild || !name) {
              continue;
            }
            const normalizedPath = (0, import_node_path26.isAbsolute)(name) ? name : (0, import_node_path26.join)(api.context.rootPath, name);
            if (!import_shared51.fse.existsSync(normalizedPath)) {
              continue;
            }
            try {
              await import_shared51.fse.copy(normalizedPath, api.context.distPath, {
                // dereference symlinks
                dereference: true
              });
            } catch (err) {
              if (err instanceof Error) {
                err.message = `Copy public dir (${normalizedPath}) to dist failed:
${err.message}`;
              }
              throw err;
            }
          }
        });
      }
    });
  }
});

// src/plugins/manifest.ts
var manifest_exports = {};
__export(manifest_exports, {
  pluginManifest: () => pluginManifest
});
var generateManifest, pluginManifest;
var init_manifest = __esm({
  "src/plugins/manifest.ts"() {
    "use strict";
    init_helpers2();
    generateManifest = (htmlPaths) => (_seed, files) => {
      const chunkEntries = /* @__PURE__ */ new Map();
      const licenseMap = /* @__PURE__ */ new Map();
      const allFiles = files.map((file) => {
        if (file.chunk) {
          const names = recursiveChunkEntryNames(file.chunk);
          for (const name of names) {
            chunkEntries.set(name, [file, ...chunkEntries.get(name) || []]);
          }
        }
        if (file.path.endsWith(".LICENSE.txt")) {
          const sourceFilePath = file.path.split(".LICENSE.txt")[0];
          licenseMap.set(sourceFilePath, file.path);
        }
        return file.path;
      });
      const entries = {};
      for (const [name, chunkFiles] of chunkEntries) {
        const assets = /* @__PURE__ */ new Set();
        const initialJS = [];
        const asyncJS = [];
        const initialCSS = [];
        const asyncCSS = [];
        for (const file of chunkFiles) {
          if (file.isInitial) {
            if (file.path.endsWith(".css")) {
              initialCSS.push(file.path);
            } else {
              initialJS.push(file.path);
            }
          } else {
            if (file.path.endsWith(".css")) {
              asyncCSS.push(file.path);
            } else {
              asyncJS.push(file.path);
            }
          }
          const relatedLICENSE = licenseMap.get(file.path);
          if (relatedLICENSE) {
            assets.add(relatedLICENSE);
          }
          for (const auxiliaryFile of file.chunk.auxiliaryFiles) {
            assets.add(auxiliaryFile);
          }
        }
        const entryManifest = {};
        if (assets.size) {
          entryManifest.assets = Array.from(assets);
        }
        const htmlPath = files.find((f) => f.name === htmlPaths[name])?.path;
        if (htmlPath) {
          entryManifest.html = [htmlPath];
        }
        if (initialJS.length) {
          entryManifest.initial = {
            js: initialJS
          };
        }
        if (initialCSS.length) {
          entryManifest.initial = {
            ...entryManifest.initial || {},
            css: initialCSS
          };
        }
        if (asyncJS.length) {
          entryManifest.async = {
            js: asyncJS
          };
        }
        if (asyncCSS.length) {
          entryManifest.async = {
            ...entryManifest.async || {},
            css: asyncCSS
          };
        }
        entries[name] = entryManifest;
      }
      return {
        allFiles,
        entries
      };
    };
    pluginManifest = () => ({
      name: "rsbuild:manifest",
      setup(api) {
        api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID3 }) => {
          const {
            output: { manifest }
          } = api.getNormalizedConfig();
          if (manifest === false) {
            return;
          }
          const fileName = typeof manifest === "string" ? manifest : "manifest.json";
          const { RspackManifestPlugin } = await import("../compiled/rspack-manifest-plugin/index.js");
          const htmlPaths = api.getHTMLPaths();
          chain.plugin(CHAIN_ID3.PLUGIN.MANIFEST).use(RspackManifestPlugin, [
            {
              fileName,
              generate: generateManifest(htmlPaths)
            }
          ]);
        });
      }
    });
  }
});

// src/plugins/moduleFederation.ts
var moduleFederation_exports = {};
__export(moduleFederation_exports, {
  pluginModuleFederation: () => pluginModuleFederation
});
function pluginModuleFederation() {
  return {
    name: "rsbuild:module-federation",
    setup(api) {
      api.modifyRsbuildConfig({
        order: "post",
        handler: (config) => {
          if (config.moduleFederation?.options && config.performance?.chunkSplit?.strategy === "split-by-experience") {
            config.performance.chunkSplit = {
              ...config.performance.chunkSplit,
              strategy: "custom"
            };
          }
          return config;
        }
      });
      api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID3, target }) => {
        const config = api.getNormalizedConfig();
        if (!config.moduleFederation?.options || target !== "web") {
          return;
        }
        const { options } = config.moduleFederation;
        chain.plugin(CHAIN_ID3.PLUGIN.MODULE_FEDERATION).use(import_core8.rspack.container.ModuleFederationPlugin, [options]);
        if (options.name) {
          chain.plugin("mf-patch-split-chunks").use(PatchSplitChunksPlugin, [options.name]);
        }
        const publicPath = chain.output.get("publicPath");
        if (publicPath === import_shared52.DEFAULT_ASSET_PREFIX) {
          chain.output.set("publicPath", "auto");
        }
      });
    }
  };
}
var import_shared52, import_core8, PatchSplitChunksPlugin;
var init_moduleFederation = __esm({
  "src/plugins/moduleFederation.ts"() {
    "use strict";
    import_shared52 = require("@rsbuild/shared");
    import_core8 = require("@rspack/core");
    PatchSplitChunksPlugin = class {
      constructor(name) {
        __publicField(this, "name");
        this.name = name;
      }
      apply(compiler) {
        const { splitChunks } = compiler.options.optimization;
        if (!splitChunks) {
          return;
        }
        const applyPatch = (cacheGroup) => {
          if (typeof cacheGroup !== "object" || cacheGroup instanceof RegExp) {
            return;
          }
          const { chunks } = cacheGroup;
          if (!chunks) {
            return;
          }
          if (typeof chunks === "function") {
            const prevChunks = chunks;
            cacheGroup.chunks = (chunk) => {
              if (chunk.name && chunk.name === this.name) {
                return false;
              }
              return prevChunks(chunk);
            };
            return;
          }
          if (chunks === "all") {
            cacheGroup.chunks = (chunk) => {
              if (chunk.name && chunk.name === this.name) {
                return false;
              }
              return true;
            };
            return;
          }
          if (chunks === "initial") {
            cacheGroup.chunks = (chunk) => {
              if (chunk.name && chunk.name === this.name) {
                return false;
              }
              return chunk.isOnlyInitial();
            };
            return;
          }
        };
        applyPatch(splitChunks);
        const { cacheGroups } = splitChunks;
        if (!cacheGroups) {
          return;
        }
        for (const cacheGroupKey of Object.keys(cacheGroups)) {
          applyPatch(cacheGroups[cacheGroupKey]);
        }
      }
    };
  }
});

// src/plugins/rspackProfile.ts
var rspackProfile_exports = {};
__export(rspackProfile_exports, {
  pluginRspackProfile: () => pluginRspackProfile,
  stopProfiler: () => stopProfiler
});
var import_node_inspector, import_node_path27, import_shared53, import_shared54, import_core9, stopProfiler, pluginRspackProfile;
var init_rspackProfile = __esm({
  "src/plugins/rspackProfile.ts"() {
    "use strict";
    import_node_inspector = __toESM(require("inspector"));
    import_node_path27 = __toESM(require("path"));
    import_shared53 = require("@rsbuild/shared");
    import_shared54 = require("@rsbuild/shared");
    import_core9 = require("@rspack/core");
    stopProfiler = (output, profileSession) => {
      if (!profileSession) {
        return;
      }
      profileSession.post("Profiler.stop", (error, param) => {
        if (error) {
          import_shared54.logger.error("Failed to generate JS CPU profile:", error);
          return;
        }
        import_shared53.fse.writeFileSync(output, JSON.stringify(param.profile));
      });
    };
    pluginRspackProfile = () => ({
      name: "rsbuild:rspack-profile",
      async setup(api) {
        if (api.context.bundlerType === "webpack") {
          return;
        }
        const RSPACK_PROFILE = process.env.RSPACK_PROFILE?.toUpperCase();
        if (!RSPACK_PROFILE) {
          return;
        }
        const timestamp = Date.now();
        const profileDir = import_node_path27.default.join(
          api.context.distPath,
          `rspack-profile-${timestamp}`
        );
        let profileSession;
        const enableProfileTrace = RSPACK_PROFILE === "ALL" || RSPACK_PROFILE.includes("TRACE");
        const enableCPUProfile = RSPACK_PROFILE === "ALL" || RSPACK_PROFILE.includes("CPU");
        const enableLogging = RSPACK_PROFILE === "ALL" || RSPACK_PROFILE.includes("LOGGING");
        const traceFilePath = import_node_path27.default.join(profileDir, "trace.json");
        const cpuProfilePath = import_node_path27.default.join(profileDir, "jscpuprofile.json");
        const loggingFilePath = import_node_path27.default.join(profileDir, "logging.json");
        const onStart = () => {
          import_shared53.fse.ensureDirSync(profileDir);
          if (enableProfileTrace) {
            import_core9.rspack.experimental_registerGlobalTrace(
              "trace",
              "chrome",
              traceFilePath
            );
          }
          if (enableCPUProfile) {
            profileSession = new import_node_inspector.default.Session();
            profileSession.connect();
            profileSession.post("Profiler.enable");
            profileSession.post("Profiler.start");
          }
        };
        api.onBeforeBuild(onStart);
        api.onBeforeStartDevServer(onStart);
        api.onAfterBuild(async ({ stats }) => {
          if (enableLogging && stats) {
            const logging = stats.toJson({
              all: false,
              logging: "verbose",
              loggingTrace: true
            });
            import_shared53.fse.writeFileSync(loggingFilePath, JSON.stringify(logging));
          }
        });
        api.onExit(() => {
          if (enableProfileTrace) {
            import_core9.rspack.experimental_cleanupGlobalTrace();
          }
          stopProfiler(cpuProfilePath, profileSession);
          import_shared54.logger.info(`Saved Rspack profile file to ${profileDir}`);
        });
      }
    });
  }
});

// src/plugins/lazyCompilation.ts
var lazyCompilation_exports = {};
__export(lazyCompilation_exports, {
  pluginLazyCompilation: () => pluginLazyCompilation
});
var import_shared55, pluginLazyCompilation;
var init_lazyCompilation = __esm({
  "src/plugins/lazyCompilation.ts"() {
    "use strict";
    import_shared55 = require("@rsbuild/shared");
    pluginLazyCompilation = () => ({
      name: "rsbuild:lazy-compilation",
      setup(api) {
        api.modifyBundlerChain((chain, { isProd: isProd6, target }) => {
          if (isProd6 || target !== "web") {
            return;
          }
          const config = api.getNormalizedConfig();
          const options = config.dev?.lazyCompilation;
          if (!options) {
            return;
          }
          const cssRegExp = /\.(?:css|less|sass|scss|styl|stylus)$/;
          const isExcludedModule = (name) => {
            return (
              // exclude CSS files because Rspack does not support it yet
              // TODO: remove this after Rspack supporting it
              cssRegExp.test(name)
            );
          };
          const defaultTest = (module2) => {
            const name = module2.nameForCondition();
            if (!name) {
              return false;
            }
            return !isExcludedModule(name);
          };
          const mergeOptions = () => {
            if (options === true) {
              return { test: defaultTest };
            }
            const { test } = options;
            if (!test) {
              return {
                ...options,
                test: defaultTest
              };
            }
            return {
              ...options,
              test(module2) {
                const name = module2.nameForCondition();
                if (!name || isExcludedModule(name)) {
                  return false;
                }
                if ((0, import_shared55.isRegExp)(test)) {
                  return name ? test.test(name) : false;
                }
                return test(module2);
              }
            };
          };
          chain.experiments({
            ...chain.get("experiments"),
            lazyCompilation: mergeOptions()
          });
        });
      }
    });
  }
});

// src/plugins/sri.ts
var sri_exports = {};
__export(sri_exports, {
  pluginSri: () => pluginSri
});
var import_node_crypto2, import_shared56, getAssetName, pluginSri;
var init_sri = __esm({
  "src/plugins/sri.ts"() {
    "use strict";
    import_node_crypto2 = __toESM(require("crypto"));
    import_shared56 = require("@rsbuild/shared");
    init_constants();
    getAssetName = (url2, assetPrefix) => {
      if (url2.startsWith(assetPrefix)) {
        return (0, import_shared56.removeLeadingSlash)(url2.replace(assetPrefix, ""));
      }
      return (0, import_shared56.removeLeadingSlash)(url2);
    };
    pluginSri = () => ({
      name: "rsbuild:sri",
      setup(api) {
        const placeholder = "RSBUILD_INTEGRITY_PLACEHOLDER:";
        const getAlgorithm = () => {
          const config = api.getNormalizedConfig();
          const { sri } = config.security;
          const enable = sri.enable === "auto" ? (0, import_shared56.isProd)() : sri.enable;
          if (!enable) {
            return null;
          }
          const { algorithm = "sha384" } = sri;
          return algorithm;
        };
        api.modifyHTMLTags({
          // ensure `sri` can be applied to all tags
          order: "post",
          handler(tags, { assetPrefix }) {
            const algorithm = getAlgorithm();
            if (!algorithm) {
              return tags;
            }
            const allTags = [...tags.headTags, ...tags.bodyTags];
            for (const tag of allTags) {
              let url2 = "";
              if (!tag.attrs) {
                continue;
              }
              if (tag.tag === "script" && typeof tag.attrs.src === "string") {
                url2 = tag.attrs.src;
              } else if (tag.tag === "link" && tag.attrs.rel === "stylesheet" && typeof tag.attrs.href === "string") {
                url2 = tag.attrs.href;
              }
              if (!url2) {
                continue;
              }
              const assetName = getAssetName(url2, assetPrefix);
              if (!assetName) {
                continue;
              }
              tag.attrs.integrity ??= `${placeholder}${assetName}`;
            }
            return tags;
          }
        });
        const replaceIntegrity = (htmlContent, assets, algorithm, integrityCache) => {
          const regex = /integrity="RSBUILD_INTEGRITY_PLACEHOLDER:([^"]+)"/g;
          const matches = htmlContent.matchAll(regex);
          let replacedHtml = htmlContent;
          const calcIntegrity = (algorithm2, assetName, data) => {
            if (integrityCache.has(assetName)) {
              return integrityCache.get(assetName);
            }
            const hash = import_node_crypto2.default.createHash(algorithm2).update(data).digest().toString("base64");
            const integrity = `${algorithm2}-${hash}`;
            integrityCache.set(assetName, integrity);
            return integrity;
          };
          for (const match of matches) {
            const assetName = match[1];
            if (!assetName) {
              continue;
            }
            if (assets[assetName]) {
              const integrity = calcIntegrity(
                algorithm,
                assetName,
                assets[assetName].buffer()
              );
              replacedHtml = replacedHtml.replaceAll(
                `integrity="${placeholder}${assetName}"`,
                `integrity="${integrity}"`
              );
            } else {
              import_shared56.logger.debug(
                `[rsbuild:sri] failed to generate integrity for ${assetName}.`
              );
              replacedHtml = replacedHtml.replace(
                `integrity="${placeholder}${assetName}"`,
                ""
              );
            }
          }
          return replacedHtml;
        };
        class SriReplaceIntegrityPlugin {
          constructor(algorithm) {
            __publicField(this, "algorithm");
            this.algorithm = algorithm;
          }
          apply(compiler) {
            compiler.hooks.compilation.tap(
              "SriReplaceIntegrityPlugin",
              (compilation) => {
                compilation.hooks.processAssets.tapPromise(
                  {
                    name: "SriReplaceIntegrityPlugin",
                    // use to final stage to get the final asset content
                    stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_REPORT
                  },
                  async (assets) => {
                    const integrityCache = /* @__PURE__ */ new Map();
                    for (const asset of Object.keys(assets)) {
                      if (!HTML_REGEX.test(asset)) {
                        continue;
                      }
                      const htmlContent = assets[asset].source();
                      if (!htmlContent.includes(placeholder)) {
                        continue;
                      }
                      assets[asset] = new compiler.webpack.sources.RawSource(
                        replaceIntegrity(
                          htmlContent,
                          assets,
                          this.algorithm,
                          integrityCache
                        )
                      );
                    }
                  }
                );
              }
            );
          }
        }
        api.modifyBundlerChain((chain, { target }) => {
          const config = api.getNormalizedConfig();
          if ((0, import_shared56.isHtmlDisabled)(config, target)) {
            return;
          }
          const algorithm = getAlgorithm();
          if (!algorithm) {
            return;
          }
          chain.plugin("rsbuild-sri-replace").use(SriReplaceIntegrityPlugin, [algorithm]);
        });
      }
    });
  }
});

// src/plugins/nonce.ts
var nonce_exports = {};
__export(nonce_exports, {
  pluginNonce: () => pluginNonce
});
var import_shared57, pluginNonce;
var init_nonce = __esm({
  "src/plugins/nonce.ts"() {
    "use strict";
    import_shared57 = require("@rsbuild/shared");
    pluginNonce = () => ({
      name: "rsbuild:nonce",
      setup(api) {
        api.onAfterCreateCompiler(({ compiler }) => {
          const { nonce } = api.getNormalizedConfig().security;
          if (!nonce) {
            return;
          }
          (0, import_shared57.applyToCompiler)(compiler, (compiler2) => {
            const { plugins } = compiler2.options;
            const hasHTML = plugins.some(
              (plugin) => plugin && plugin.constructor.name === "HtmlBasicPlugin"
            );
            if (!hasHTML) {
              return;
            }
            const injectCode = (0, import_shared57.createVirtualModule)(
              `__webpack_nonce__ = "${nonce}";`
            );
            new compiler2.webpack.EntryPlugin(compiler2.context, injectCode, {
              name: void 0
            }).apply(compiler2);
          });
        });
        api.modifyHTMLTags({
          // ensure `nonce` can be applied to all tags
          order: "post",
          handler: ({ headTags, bodyTags }) => {
            const config = api.getNormalizedConfig();
            const { nonce } = config.security;
            const allTags = [...headTags, ...bodyTags];
            if (nonce) {
              for (const tag of allTags) {
                if (tag.tag === "script" || tag.tag === "style") {
                  tag.attrs ??= {};
                  tag.attrs.nonce = nonce;
                }
              }
            }
            return { headTags, bodyTags };
          }
        });
      }
    });
  }
});

// src/createRsbuild.ts
var createRsbuild_exports = {};
__export(createRsbuild_exports, {
  createRsbuild: () => createRsbuild,
  pickRsbuildConfig: () => pickRsbuildConfig
});
async function applyDefaultPlugins(pluginManager, context) {
  const { pluginBasic: pluginBasic2 } = await Promise.resolve().then(() => (init_basic(), basic_exports));
  const { pluginEntry: pluginEntry2 } = await Promise.resolve().then(() => (init_entry(), entry_exports));
  const { pluginCache: pluginCache2 } = await Promise.resolve().then(() => (init_cache(), cache_exports));
  const { pluginTarget: pluginTarget2 } = await Promise.resolve().then(() => (init_target(), target_exports));
  const { pluginOutput: pluginOutput2 } = await Promise.resolve().then(() => (init_output(), output_exports));
  const { pluginResolve: pluginResolve2 } = await Promise.resolve().then(() => (init_resolve(), resolve_exports));
  const { pluginFileSize: pluginFileSize2 } = await Promise.resolve().then(() => (init_fileSize(), fileSize_exports));
  const { pluginCleanOutput: pluginCleanOutput2 } = await Promise.resolve().then(() => (init_cleanOutput(), cleanOutput_exports));
  const { pluginAsset: pluginAsset2 } = await Promise.resolve().then(() => (init_asset(), asset_exports));
  const { pluginHtml: pluginHtml2 } = await Promise.resolve().then(() => (init_html(), html_exports));
  const { pluginWasm: pluginWasm2 } = await Promise.resolve().then(() => (init_wasm(), wasm_exports));
  const { pluginMoment: pluginMoment2 } = await Promise.resolve().then(() => (init_moment(), moment_exports));
  const { pluginNodeAddons: pluginNodeAddons2 } = await Promise.resolve().then(() => (init_nodeAddons(), nodeAddons_exports));
  const { pluginDefine: pluginDefine2 } = await Promise.resolve().then(() => (init_define(), define_exports));
  const { pluginCss: pluginCss2 } = await Promise.resolve().then(() => (init_css(), css_exports));
  const { pluginMinimize: pluginMinimize2 } = await Promise.resolve().then(() => (init_minimize(), minimize_exports));
  const { pluginProgress: pluginProgress2 } = await Promise.resolve().then(() => (init_progress(), progress_exports));
  const { pluginSwc: pluginSwc2 } = await Promise.resolve().then(() => (init_swc(), swc_exports));
  const { pluginExternals: pluginExternals2 } = await Promise.resolve().then(() => (init_externals(), externals_exports));
  const { pluginSplitChunks: pluginSplitChunks2 } = await Promise.resolve().then(() => (init_splitChunks(), splitChunks_exports));
  const { pluginOpen: pluginOpen2 } = await Promise.resolve().then(() => (init_open(), open_exports));
  const { pluginInlineChunk: pluginInlineChunk2 } = await Promise.resolve().then(() => (init_inlineChunk(), inlineChunk_exports));
  const { pluginBundleAnalyzer: pluginBundleAnalyzer2 } = await Promise.resolve().then(() => (init_bundleAnalyzer(), bundleAnalyzer_exports));
  const { pluginRsdoctor: pluginRsdoctor2 } = await Promise.resolve().then(() => (init_rsdoctor(), rsdoctor_exports));
  const { pluginResourceHints: pluginResourceHints2 } = await Promise.resolve().then(() => (init_resourceHints(), resourceHints_exports));
  const { pluginPerformance: pluginPerformance2 } = await Promise.resolve().then(() => (init_performance(), performance_exports));
  const { pluginServer: pluginServer2 } = await Promise.resolve().then(() => (init_server(), server_exports));
  const { pluginManifest: pluginManifest2 } = await Promise.resolve().then(() => (init_manifest(), manifest_exports));
  const { pluginModuleFederation: pluginModuleFederation2 } = await Promise.resolve().then(() => (init_moduleFederation(), moduleFederation_exports));
  const { pluginRspackProfile: pluginRspackProfile2 } = await Promise.resolve().then(() => (init_rspackProfile(), rspackProfile_exports));
  const { pluginLazyCompilation: pluginLazyCompilation2 } = await Promise.resolve().then(() => (init_lazyCompilation(), lazyCompilation_exports));
  const { pluginSri: pluginSri2 } = await Promise.resolve().then(() => (init_sri(), sri_exports));
  const { pluginNonce: pluginNonce2 } = await Promise.resolve().then(() => (init_nonce(), nonce_exports));
  pluginManager.addPlugins([
    pluginBasic2(),
    pluginEntry2(),
    pluginCache2(),
    pluginTarget2(),
    pluginOutput2(),
    pluginResolve2(),
    pluginFileSize2(),
    // cleanOutput plugin should before the html plugin
    pluginCleanOutput2(),
    pluginAsset2(),
    pluginHtml2(async (...args) => {
      const result = await context.hooks.modifyHTMLTags.call(...args);
      return result[0];
    }),
    pluginWasm2(),
    pluginMoment2(),
    pluginNodeAddons2(),
    pluginDefine2(),
    pluginCss2(),
    pluginMinimize2(),
    pluginProgress2(),
    pluginSwc2(),
    pluginExternals2(),
    pluginSplitChunks2(),
    pluginOpen2(),
    pluginInlineChunk2(),
    pluginBundleAnalyzer2(),
    pluginRsdoctor2(),
    pluginResourceHints2(),
    pluginPerformance2(),
    pluginServer2(),
    pluginManifest2(),
    pluginModuleFederation2(),
    pluginRspackProfile2(),
    pluginLazyCompilation2(),
    pluginSri2(),
    pluginNonce2()
  ]);
}
async function createRsbuild(options = {}) {
  const { rsbuildConfig = {} } = options;
  const rsbuildOptions = {
    cwd: process.cwd(),
    rsbuildConfig,
    ...options
  };
  const pluginManager = createPluginManager();
  const context = await createContext(
    rsbuildOptions,
    pickRsbuildConfig(rsbuildOptions.rsbuildConfig),
    rsbuildConfig.provider ? "webpack" : "rspack"
  );
  const pluginAPI = getPluginAPI({ context, pluginManager });
  context.pluginAPI = pluginAPI;
  (0, import_shared58.debug)("add default plugins");
  await applyDefaultPlugins(pluginManager, context);
  (0, import_shared58.debug)("add default plugins done");
  const provider = rsbuildConfig.provider || await getRspackProvider();
  const providerInstance = await provider({
    context,
    pluginManager,
    rsbuildOptions,
    setCssExtractPlugin
  });
  const rsbuild = {
    ...(0, import_shared58.pick)(pluginManager, [
      "addPlugins",
      "getPlugins",
      "removePlugins",
      "isPluginExists"
    ]),
    ...(0, import_shared58.pick)(pluginAPI, [
      "onBeforeBuild",
      "onBeforeCreateCompiler",
      "onBeforeStartDevServer",
      "onBeforeStartProdServer",
      "onAfterBuild",
      "onAfterCreateCompiler",
      "onAfterStartDevServer",
      "onAfterStartProdServer",
      "onCloseDevServer",
      "onDevCompileDone",
      "onExit",
      "getHTMLPaths",
      "getRsbuildConfig",
      "getNormalizedConfig"
    ]),
    ...(0, import_shared58.pick)(providerInstance, [
      "build",
      "preview",
      "initConfigs",
      "inspectConfig",
      "createCompiler",
      "createDevServer",
      "startDevServer"
    ]),
    context: pluginAPI.context
  };
  if (rsbuildConfig.plugins) {
    const plugins = await Promise.all(rsbuildConfig.plugins);
    rsbuild.addPlugins(plugins);
  }
  return rsbuild;
}
var import_shared58, getRspackProvider, pickRsbuildConfig;
var init_createRsbuild = __esm({
  "src/createRsbuild.ts"() {
    "use strict";
    import_shared58 = require("@rsbuild/shared");
    init_createContext();
    init_initPlugins();
    init_pluginHelper();
    init_pluginManager();
    getRspackProvider = async () => {
      const { rspackProvider: rspackProvider2 } = await Promise.resolve().then(() => (init_provider(), provider_exports));
      return rspackProvider2;
    };
    pickRsbuildConfig = (rsbuildConfig) => {
      const keys = [
        "dev",
        "html",
        "tools",
        "output",
        "source",
        "server",
        "security",
        "performance",
        "moduleFederation",
        "_privateMeta"
      ];
      return (0, import_shared58.pick)(rsbuildConfig, keys);
    };
  }
});

// src/cli/init.ts
async function init({
  cliOptions,
  isRestart
}) {
  if (cliOptions) {
    commonOpts = cliOptions;
  }
  try {
    const root = process.cwd();
    const envs = loadEnv({
      cwd: root,
      mode: cliOptions?.envMode
    });
    if ((0, import_shared59.isDev)()) {
      onBeforeRestartServer(envs.cleanup);
    }
    const { content: config, filePath: configFilePath } = await loadConfig({
      cwd: root,
      path: commonOpts.config,
      envMode: commonOpts.envMode
    });
    const command = process.argv[2];
    if (command === "dev") {
      const files = [...envs.filePaths];
      if (configFilePath) {
        files.push(configFilePath);
      }
      watchFiles(files);
    }
    const { createRsbuild: createRsbuild2 } = await Promise.resolve().then(() => (init_createRsbuild(), createRsbuild_exports));
    config.source ||= {};
    config.source.define = {
      ...envs.publicVars,
      ...config.source.define
    };
    if (commonOpts.open && !config.server?.open) {
      config.server ||= {};
      config.server.open = commonOpts.open;
    }
    if (commonOpts.host) {
      config.server ||= {};
      config.server.host = commonOpts.host;
    }
    if (commonOpts.port) {
      config.server ||= {};
      config.server.port = commonOpts.port;
    }
    return createRsbuild2({
      cwd: root,
      rsbuildConfig: config
    });
  } catch (err) {
    if (isRestart) {
      import_shared59.logger.error(err);
    } else {
      throw err;
    }
  }
}
var import_shared59, commonOpts;
var init_init = __esm({
  "src/cli/init.ts"() {
    "use strict";
    import_shared59 = require("@rsbuild/shared");
    init_config();
    init_loadEnv();
    init_restart();
    commonOpts = {};
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  PLUGIN_CSS_NAME: () => PLUGIN_CSS_NAME,
  PLUGIN_SWC_NAME: () => PLUGIN_SWC_NAME,
  __internalHelper: () => internal_exports,
  createRsbuild: () => createRsbuild,
  defineConfig: () => defineConfig,
  loadConfig: () => loadConfig,
  loadEnv: () => loadEnv,
  logger: () => import_shared62.logger,
  mergeRsbuildConfig: () => mergeRsbuildConfig,
  rspack: () => import_core10.rspack,
  version: () => version
});
module.exports = __toCommonJS(src_exports);
var import_core10 = require("@rspack/core");

// src/internal.ts
var internal_exports = {};
__export(internal_exports, {
  applySwcDecoratorConfig: () => applySwcDecoratorConfig,
  createDevServer: () => createDevServer,
  createPluginManager: () => createPluginManager,
  formatStats: () => formatStats,
  getChainUtils: () => getChainUtils,
  getDevMiddleware: () => getDevMiddleware,
  getHTMLPlugin: () => getHTMLPlugin,
  getStatsOptions: () => getStatsOptions,
  getSwcMinimizerOptions: () => getSwcMinimizerOptions,
  initHooks: () => initHooks,
  initPlugins: () => initPlugins,
  initRsbuildConfig: () => initRsbuildConfig,
  outputInspectConfigFiles: () => outputInspectConfigFiles,
  prepareCli: () => prepareCli,
  runCli: () => runCli,
  setHTMLPlugin: () => setHTMLPlugin,
  startProdServer: () => startProdServer,
  stringifyConfig: () => stringifyConfig
});

// src/cli/commands.ts
var import_node_fs5 = require("fs");
var import_node_path28 = require("path");
var import_shared60 = require("@rsbuild/shared");
var import_commander = require("../compiled/commander/index.js");
init_helpers();
init_init();
var applyCommonOptions = (command) => {
  command.option(
    "-c --config <config>",
    "specify the configuration file, can be a relative or absolute path"
  ).option(
    "--env-mode <mode>",
    "specify the env mode to load the `.env.[mode]` file"
  );
};
var applyServerOptions = (command) => {
  command.option("-o --open [url]", "open the page in browser on startup").option("--port <port>", "specify a port number for server to listen").option("--host <host>", "specify the host that the server listens to");
};
function runCli() {
  import_commander.program.name("rsbuild").usage("<command> [options]").version("0.7.7");
  const devCommand = import_commander.program.command("dev");
  const buildCommand = import_commander.program.command("build");
  const previewCommand = import_commander.program.command("preview");
  const inspectCommand = import_commander.program.command("inspect");
  [devCommand, buildCommand, previewCommand, inspectCommand].forEach(
    applyCommonOptions
  );
  [devCommand, previewCommand].forEach(applyServerOptions);
  devCommand.description("starting the dev server").action(async (options) => {
    try {
      const rsbuild = await init({ cliOptions: options });
      await rsbuild?.startDevServer();
    } catch (err) {
      import_shared60.logger.error("Failed to start dev server.");
      import_shared60.logger.error(err);
      process.exit(1);
    }
  });
  buildCommand.option("-w --watch", "turn on watch mode, watch for changes and rebuild").description("build the app for production").action(async (options) => {
    try {
      const rsbuild = await init({ cliOptions: options });
      await rsbuild?.build({
        watch: options.watch
      });
    } catch (err) {
      import_shared60.logger.error("Failed to build.");
      import_shared60.logger.error(err);
      process.exit(1);
    }
  });
  previewCommand.description("preview the production build locally").action(async (options) => {
    try {
      const rsbuild = await init({ cliOptions: options });
      if (rsbuild) {
        const { distPath } = rsbuild.context;
        if (!(0, import_node_fs5.existsSync)(distPath)) {
          throw new Error(
            `The output directory ${import_shared60.color.yellow(
              distPath
            )} does not exist, please build the project before previewing.`
          );
        }
        if (isEmptyDir(distPath)) {
          throw new Error(
            `The output directory ${import_shared60.color.yellow(
              distPath
            )} is empty, please build the project before previewing.`
          );
        }
      }
      await rsbuild?.preview();
    } catch (err) {
      import_shared60.logger.error("Failed to start preview server.");
      import_shared60.logger.error(err);
      process.exit(1);
    }
  });
  inspectCommand.description("inspect the Rspack and Rsbuild configs").option("--env <env>", "specify env mode", "development").option("--output <output>", "specify inspect content output path", "/").option("--verbose", "show full function definitions in output").action(async (options) => {
    try {
      const rsbuild = await init({ cliOptions: options });
      await rsbuild?.inspectConfig({
        env: options.env,
        verbose: options.verbose,
        outputPath: (0, import_node_path28.join)(rsbuild.context.distPath, options.output),
        writeToDisk: true
      });
    } catch (err) {
      import_shared60.logger.error("Failed to inspect config.");
      import_shared60.logger.error(err);
      process.exit(1);
    }
  });
  import_commander.program.parse();
}

// src/cli/prepare.ts
var import_shared61 = require("@rsbuild/shared");
function initNodeEnv() {
  if (!process.env.NODE_ENV) {
    const command = process.argv[2];
    process.env.NODE_ENV = ["build", "preview"].includes(command) ? "production" : "development";
  }
}
function prepareCli() {
  initNodeEnv();
  const { npm_execpath } = process.env;
  if (!npm_execpath || npm_execpath.includes("npx-cli.js") || npm_execpath.includes(".bun")) {
    console.log();
  }
  import_shared61.logger.greet(`  ${`Rsbuild v${"0.7.7"}`}
`);
}

// src/internal.ts
init_pluginManager();
init_initHooks();
init_initConfigs();
init_config();
init_pluginHelper();
init_helpers();
init_rspackConfig();
init_swc();
init_minimize();
init_devMiddleware();

// src/server/index.ts
init_devServer();
init_prodServer();

// src/index.ts
init_loadEnv();
init_createRsbuild();
init_config();
var import_shared62 = require("@rsbuild/shared");
init_mergeConfig();
init_constants();
var version = "0.7.7";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PLUGIN_CSS_NAME,
  PLUGIN_SWC_NAME,
  __internalHelper,
  createRsbuild,
  defineConfig,
  loadConfig,
  loadEnv,
  logger,
  mergeRsbuildConfig,
  rspack,
  version
});
/**
 * @license
 * Copyright 2018 Google Inc.
 * https://github.com/vuejs/preload-webpack-plugin/blob/master/src/lib/extract-chunks.js
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google Inc.
 * https://github.com/vuejs/preload-webpack-plugin/blob/master/src/lib/determine-as-value.js
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google Inc.
 * https://github.com/vuejs/preload-webpack-plugin/blob/master/src/lib/does-chunk-belong-to-html.js
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google Inc.
 * https://github.com/vuejs/preload-webpack-plugin/blob/master/src/index.js
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
