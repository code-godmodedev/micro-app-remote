"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CHAIN_ID: () => CHAIN_ID,
  DEFAULT_ASSET_PREFIX: () => DEFAULT_ASSET_PREFIX,
  DEFAULT_BROWSERSLIST: () => DEFAULT_BROWSERSLIST,
  JS_REGEX: () => JS_REGEX,
  NODE_MODULES_REGEX: () => NODE_MODULES_REGEX,
  RspackChain: () => import_rspack_chain.default,
  SCRIPT_REGEX: () => SCRIPT_REGEX,
  TARGET_ID_MAP: () => TARGET_ID_MAP,
  TS_AND_JSX_REGEX: () => TS_AND_JSX_REGEX,
  TS_REGEX: () => TS_REGEX,
  addTrailingSlash: () => addTrailingSlash,
  applyScriptCondition: () => applyScriptCondition,
  applyToCompiler: () => applyToCompiler,
  browserslistToESVersion: () => browserslistToESVersion,
  camelCase: () => camelCase,
  canParse: () => canParse,
  castArray: () => castArray,
  chainToConfig: () => chainToConfig,
  cloneDeep: () => cloneDeep,
  color: () => import_picocolors.default,
  createCacheGroups: () => createCacheGroups,
  createDependenciesRegExp: () => createDependenciesRegExp,
  createVirtualModule: () => createVirtualModule,
  debounce: () => debounce,
  debug: () => debug,
  deepmerge: () => import_deepmerge.default,
  fse: () => import_fs_extra2.default,
  generateScriptTag: () => generateScriptTag,
  getBrowserslist: () => getBrowserslist,
  getBrowserslistWithDefault: () => getBrowserslistWithDefault,
  getBundlerChain: () => getBundlerChain,
  getCoreJsVersion: () => getCoreJsVersion,
  getDistPath: () => getDistPath,
  getFilename: () => getFilename,
  getJsSourceMap: () => getJsSourceMap,
  getNodeEnv: () => getNodeEnv,
  getPublicPathFromCompiler: () => getPublicPathFromCompiler,
  getSharedPkgCompiledPath: () => getSharedPkgCompiledPath,
  isClientCompiler: () => isClientCompiler,
  isDebug: () => isDebug,
  isDev: () => isDev,
  isFunction: () => isFunction,
  isHtmlDisabled: () => isHtmlDisabled,
  isMultiCompiler: () => isMultiCompiler,
  isNil: () => isNil,
  isNodeCompiler: () => isNodeCompiler,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  isProd: () => isProd,
  isRegExp: () => isRegExp,
  isServerTarget: () => isServerTarget,
  isString: () => isString,
  isTest: () => isTest,
  isURL: () => isURL,
  isUndefined: () => isUndefined,
  isUsingHMR: () => isUsingHMR,
  isWebTarget: () => isWebTarget,
  kebabCase: () => kebabCase,
  logger: () => logger,
  modifyBundlerChain: () => modifyBundlerChain,
  normalizeUrl: () => normalizeUrl,
  onCompileDone: () => onCompileDone,
  partition: () => partition,
  pick: () => pick,
  prettyTime: () => prettyTime,
  reduceConfigs: () => reduceConfigs,
  reduceConfigsAsyncWithContext: () => reduceConfigsAsyncWithContext,
  reduceConfigsMergeContext: () => reduceConfigsMergeContext,
  reduceConfigsWithContext: () => reduceConfigsWithContext,
  removeLeadingSlash: () => removeLeadingSlash,
  removeTailingSlash: () => removeTailingSlash,
  setNodeEnv: () => setNodeEnv,
  upperFirst: () => upperFirst,
  withPublicPath: () => withPublicPath
});
module.exports = __toCommonJS(src_exports);

// src/constants.ts
var DEFAULT_WEB_BROWSERSLIST = [
  "chrome >= 87",
  "edge >= 88",
  "firefox >= 78",
  "safari >= 14"
];
var DEFAULT_BROWSERSLIST = {
  web: DEFAULT_WEB_BROWSERSLIST,
  "web-worker": DEFAULT_WEB_BROWSERSLIST,
  "service-worker": DEFAULT_WEB_BROWSERSLIST,
  node: ["node >= 16"]
};
var DEFAULT_ASSET_PREFIX = "/";
var JS_REGEX = /\.(?:js|mjs|cjs|jsx)$/;
var TS_REGEX = /\.(?:ts|mts|cts|tsx)$/;
var SCRIPT_REGEX = /\.(?:js|jsx|mjs|cjs|ts|tsx|mts|cts)$/;
var TS_AND_JSX_REGEX = /\.(?:ts|tsx|jsx|mts|cts)$/;
var NODE_MODULES_REGEX = /[\\/]node_modules[\\/]/;
var TARGET_ID_MAP = {
  web: "Client",
  node: "Server",
  "web-worker": "Web Worker",
  "service-worker": "Service Worker"
};

// src/utils.ts
var import_node_path = __toESM(require("path"));
var import_deepmerge = __toESM(require("../compiled/deepmerge/index.js"));
var import_fs_extra = __toESM(require("../compiled/fs-extra/index.js"));
var import_picocolors = __toESM(require("../compiled/picocolors/index.js"));
var getNodeEnv = () => process.env.NODE_ENV;
var setNodeEnv = (env2) => {
  process.env.NODE_ENV = env2;
};
var isDev = () => getNodeEnv() === "development";
var isProd = () => getNodeEnv() === "production";
var isTest = () => getNodeEnv() === "test";
var isString = (str) => typeof str === "string";
var isUndefined = (obj) => typeof obj === "undefined";
var isFunction = (func) => typeof func === "function";
var isObject = (obj) => obj !== null && typeof obj === "object";
var isPlainObject = (obj) => isObject(obj) && Object.prototype.toString.call(obj) === "[object Object]";
var isRegExp = (obj) => Object.prototype.toString.call(obj) === "[object RegExp]";
var isNil = (o) => o === void 0 || o === null;
var createVirtualModule = (content) => `data:text/javascript,${content}`;
var removeLeadingSlash = (s) => s.replace(/^\/+/, "");
var removeTailingSlash = (s) => s.replace(/\/+$/, "");
var addTrailingSlash = (s) => s.endsWith("/") ? s : `${s}/`;
var getJsSourceMap = (config) => {
  const { sourceMap } = config.output;
  if (sourceMap.js === void 0) {
    return isProd() ? false : "cheap-module-source-map";
  }
  return sourceMap.js;
};
var getSharedPkgCompiledPath = (packageName) => import_node_path.default.join(__dirname, "../compiled", packageName);
var isURL = (str) => str.startsWith("http") || str.startsWith("//:");
function isWebTarget(target) {
  return ["web", "web-worker"].some(
    (t) => (Array.isArray(target) ? target : [target]).includes(t)
  );
}
function isServerTarget(target) {
  return (Array.isArray(target) ? target : [target]).some(
    (item) => ["node", "service-worker"].includes(item)
  );
}
var getCoreJsVersion = (corejsPkgPath) => {
  try {
    const { version } = import_fs_extra.default.readJSONSync(corejsPkgPath);
    const [major, minor] = version.split(".");
    return `${major}.${minor}`;
  } catch (err) {
    return "3";
  }
};
var castArray = (arr) => {
  if (arr === void 0) {
    return [];
  }
  return Array.isArray(arr) ? arr : [arr];
};
var camelCase = (input) => input.replace(/[-_](\w)/g, (_, c) => c.toUpperCase());
var kebabCase = (str) => str.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
var cloneDeep = (value) => {
  if (value === null || value === void 0) {
    return value;
  }
  return (0, import_deepmerge.default)({}, value);
};
var DEP_MATCH_TEMPLATE = /[\\/]node_modules[\\/](<SOURCES>)[\\/]/.source;
var createDependenciesRegExp = (...dependencies) => {
  const sources = dependencies.map(
    (d) => typeof d === "string" ? d : d.source
  );
  const expr = DEP_MATCH_TEMPLATE.replace("<SOURCES>", sources.join("|"));
  return new RegExp(expr);
};
function createCacheGroups(group) {
  const experienceCacheGroup = {};
  for (const [name, pkgs] of Object.entries(group)) {
    const key = `lib-${name}`;
    experienceCacheGroup[key] = {
      test: createDependenciesRegExp(...pkgs),
      priority: 0,
      name: key,
      reuseExistingChunk: true
    };
  }
  return experienceCacheGroup;
}
function debounce(func, wait) {
  let timeoutId = null;
  return (...args) => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      func(...args);
    }, wait);
  };
}
var upperFirst = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1) : "";
var generateScriptTag = () => ({
  tagName: "script",
  attributes: {
    type: "text/javascript"
  },
  voidTag: false,
  meta: {}
});
var getPublicPathFromCompiler = (compiler) => {
  const { publicPath } = compiler.options.output;
  if (typeof publicPath === "string") {
    if (publicPath === "auto") {
      return "";
    }
    return addTrailingSlash(publicPath);
  }
  return DEFAULT_ASSET_PREFIX;
};
function partition(array, predicate) {
  const truthy = [];
  const falsy = [];
  for (const value of array) {
    if (predicate(value)) {
      truthy.push(value);
    } else {
      falsy.push(value);
    }
  }
  return [truthy, falsy];
}
function pick(obj, keys) {
  return keys.reduce(
    (ret, key) => {
      if (obj[key] !== void 0) {
        ret[key] = obj[key];
      }
      return ret;
    },
    {}
  );
}
var prettyTime = (seconds) => {
  const format = (time) => import_picocolors.default.bold(time);
  if (seconds < 10) {
    const digits = seconds >= 0.01 ? 2 : 3;
    return `${format(seconds.toFixed(digits))} s`;
  }
  if (seconds < 60) {
    return `${format(seconds.toFixed(1))} s`;
  }
  const minutes = seconds / 60;
  return `${format(minutes.toFixed(2))} m`;
};
var isHtmlDisabled = (config, target) => {
  const { htmlPlugin } = config.tools;
  return htmlPlugin === false || Array.isArray(htmlPlugin) && htmlPlugin.includes(false) || target !== "web";
};
function isUsingHMR(config, { isProd: isProd2, target }) {
  return !isProd2 && config.dev.hmr && target === "web";
}
var isClientCompiler = (compiler) => {
  const { target } = compiler.options;
  if (target) {
    return Array.isArray(target) ? target.includes("web") : target === "web";
  }
  return false;
};
var isNodeCompiler = (compiler) => {
  const { target } = compiler.options;
  if (target) {
    return Array.isArray(target) ? target.includes("node") : target === "node";
  }
  return false;
};
var isMultiCompiler = (compiler) => {
  return compiler.constructor.name === "MultiCompiler";
};
var applyToCompiler = (compiler, apply) => {
  if (isMultiCompiler(compiler)) {
    compiler.compilers.forEach(apply);
  } else {
    apply(compiler);
  }
};
var onCompileDone = (compiler, onDone, MultiStatsCtor) => {
  if (isMultiCompiler(compiler)) {
    const { compilers } = compiler;
    const compilerStats = [];
    let doneCompilers = 0;
    for (let index = 0; index < compilers.length; index++) {
      const compiler2 = compilers[index];
      const compilerIndex = index;
      let compilerDone = false;
      compiler2.hooks.done.tapPromise("rsbuild:done", async (stats) => {
        if (!compilerDone) {
          compilerDone = true;
          doneCompilers++;
        }
        compilerStats[compilerIndex] = stats;
        if (doneCompilers === compilers.length) {
          await onDone(new MultiStatsCtor(compilerStats));
        }
      });
      compiler2.hooks.invalid.tap("rsbuild:done", () => {
        if (compilerDone) {
          compilerDone = false;
          doneCompilers--;
        }
      });
    }
  } else {
    compiler.hooks.done.tapPromise("rsbuild:done", onDone);
  }
};

// src/fs.ts
var import_fs_extra2 = __toESM(require("../compiled/fs-extra/index.js"));
var getDistPath = (config, type) => {
  const { distPath } = config.output || {};
  const ret = distPath?.[type];
  if (typeof ret !== "string") {
    if (type === "jsAsync") {
      const jsPath = getDistPath(config, "js");
      return jsPath ? `${jsPath}/async` : "async";
    }
    if (type === "cssAsync") {
      const cssPath = getDistPath(config, "css");
      return cssPath ? `${cssPath}/async` : "async";
    }
    throw new Error(`unknown key ${type} in "output.distPath"`);
  }
  return ret;
};
function getFilename(config, type, isProd2) {
  const { filename, filenameHash } = config.output;
  const getHash = () => {
    if (typeof filenameHash === "string") {
      return filenameHash ? `.[${filenameHash}]` : "";
    }
    return filenameHash ? ".[contenthash:8]" : "";
  };
  const hash = getHash();
  switch (type) {
    case "js":
      return filename.js ?? `[name]${isProd2 ? hash : ""}.js`;
    case "css":
      return filename.css ?? `[name]${isProd2 ? hash : ""}.css`;
    case "svg":
      return filename.svg ?? `[name]${hash}.svg`;
    case "font":
      return filename.font ?? `[name]${hash}[ext]`;
    case "image":
      return filename.image ?? `[name]${hash}[ext]`;
    case "media":
      return filename.media ?? `[name]${hash}[ext]`;
    default:
      throw new Error(`unknown key ${type} in "output.filename"`);
  }
}

// src/getBrowserslist.ts
var import_browserslist = __toESM(require("../compiled/browserslist/index.js"));
var browsersListCache = /* @__PURE__ */ new Map();
async function getBrowserslist(path2) {
  const env2 = getNodeEnv();
  const cacheKey = path2 + env2;
  if (browsersListCache.has(cacheKey)) {
    return browsersListCache.get(cacheKey);
  }
  const result = import_browserslist.default.loadConfig({ path: path2, env: env2 });
  if (result) {
    browsersListCache.set(cacheKey, result);
    return result;
  }
  return null;
}
async function getBrowserslistWithDefault(path2, config, target) {
  const { overrideBrowserslist: overrides = {} } = config?.output || {};
  if (target === "web" || target === "web-worker") {
    if (Array.isArray(overrides)) {
      return overrides;
    }
    if (overrides[target]) {
      return overrides[target];
    }
    const browserslistrc = await getBrowserslist(path2);
    if (browserslistrc) {
      return browserslistrc;
    }
  }
  if (!Array.isArray(overrides) && overrides[target]) {
    return overrides[target];
  }
  return DEFAULT_BROWSERSLIST[target];
}
var ES_VERSIONS_MAP = {
  chrome: [51, 52, 57, 64],
  edge: [15, 15, 15, 79],
  safari: [10, 10.3, 11, 16.4],
  firefox: [54, 54, 54, 78],
  opera: [38, 39, 44, 51],
  samsung: [5, 6.2, 6.2, 8.2]
};
var renameBrowser = (name) => {
  return name === "ios_saf" ? "safari" : name;
};
function browserslistToESVersion(browsers) {
  const projectBrowsers = (0, import_browserslist.default)(browsers, {
    ignoreUnknownVersions: true
  });
  let esVersion = 2018 /* es2018 */;
  for (const item of projectBrowsers) {
    const pairs = item.split(" ");
    if (pairs.length < 2) {
      continue;
    }
    const browser = renameBrowser(pairs[0]);
    const version = Number(pairs[1].split("-")[0]);
    if (Number.isNaN(version)) {
      continue;
    }
    if (browser === "ie" || browser === "android" && version < 6) {
      esVersion = 5 /* es5 */;
      break;
    }
    const versions = ES_VERSIONS_MAP[browser];
    if (!versions) {
      continue;
    }
    if (version < versions[0]) {
      esVersion = Math.min(5 /* es5 */, esVersion);
    } else if (version < versions[1]) {
      esVersion = Math.min(2015 /* es2015 */, esVersion);
    } else if (version < versions[2]) {
      esVersion = Math.min(2016 /* es2016 */, esVersion);
    } else if (version < versions[3]) {
      esVersion = Math.min(2017 /* es2017 */, esVersion);
    }
  }
  return esVersion;
}

// ../../node_modules/.pnpm/rslog@1.2.2/node_modules/rslog/dist/index.mjs
var import_process = __toESM(require("process"), 1);
var import_os = __toESM(require("os"), 1);
var import_tty = __toESM(require("tty"), 1);
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : import_process.default.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = import_process.default;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (import_process.default.platform === "win32") {
    const osRelease = import_os.default.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if ("GITHUB_ACTIONS" in env || "GITEA_ACTIONS" in env) {
      return 3;
    }
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: import_tty.default.isatty(1) }),
  stderr: createSupportsColor({ isTTY: import_tty.default.isatty(2) })
};
var supports_color_default = supportsColor;
var colorLevel = supports_color_default.stdout ? supports_color_default.stdout.level : 0;
var errorStackRegExp = /at\s.*:\d+:\d+[\s\)]*$/;
var anonymousErrorStackRegExp = /^\s*at\s.*\(<anonymous>\)$/;
var isErrorStackMessage = (message) => errorStackRegExp.test(message) || anonymousErrorStackRegExp.test(message);
var formatter = (open, close, replace = open) => colorLevel >= 2 ? (input) => {
  let string = "" + input;
  let index = string.indexOf(close, open.length);
  return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
} : String;
var replaceClose = (string, close, replace, index) => {
  let start = string.substring(0, index) + replace;
  let end = string.substring(index + close.length);
  let nextIndex = end.indexOf(close);
  return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
};
var bold = formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m");
var red = formatter("\x1B[31m", "\x1B[39m");
var green = formatter("\x1B[32m", "\x1B[39m");
var yellow = formatter("\x1B[33m", "\x1B[39m");
var magenta = formatter("\x1B[35m", "\x1B[39m");
var cyan = formatter("\x1B[36m", "\x1B[39m");
var gray = formatter("\x1B[90m", "\x1B[39m");
var startColor = [189, 255, 243];
var endColor = [74, 194, 154];
var isWord = (char) => !/[\s\n]/.test(char);
var gradient = (message) => {
  if (colorLevel < 3) {
    return colorLevel === 2 ? bold(cyan(message)) : message;
  }
  let chars = [...message];
  let steps = chars.filter(isWord).length;
  let r = startColor[0];
  let g = startColor[1];
  let b = startColor[2];
  let rStep = (endColor[0] - r) / steps;
  let gStep = (endColor[1] - g) / steps;
  let bStep = (endColor[2] - b) / steps;
  let output = "";
  for (let char of chars) {
    if (isWord(char)) {
      r += rStep;
      g += gStep;
      b += bStep;
    }
    output += `\x1B[38;2;${Math.round(r)};${Math.round(g)};${Math.round(
      b
    )}m${char}\x1B[39m`;
  }
  return bold(output);
};
var LOG_LEVEL = {
  error: 0,
  warn: 1,
  info: 2,
  log: 3,
  verbose: 4
};
var LOG_TYPES = {
  // Level error
  error: {
    label: "error",
    level: "error",
    color: red
  },
  // Level warn
  warn: {
    label: "warn",
    level: "warn",
    color: yellow
  },
  // Level info
  info: {
    label: "info",
    level: "info",
    color: cyan
  },
  start: {
    label: "start",
    level: "info",
    color: cyan
  },
  ready: {
    label: "ready",
    level: "info",
    color: green
  },
  success: {
    label: "success",
    level: "info",
    color: green
  },
  // Level log
  log: {
    level: "log"
  },
  // Level debug
  debug: {
    label: "debug",
    level: "verbose",
    color: magenta
  }
};
var createLogger = (options = {}) => {
  let maxLevel = options.level || "log";
  let log = (type, message, ...args) => {
    if (LOG_LEVEL[LOG_TYPES[type].level] > LOG_LEVEL[maxLevel]) {
      return;
    }
    if (message === void 0 || message === null) {
      return console.log();
    }
    let logType = LOG_TYPES[type];
    let label = "";
    let text = "";
    if ("label" in logType) {
      label = (logType.label || "").padEnd(7);
      label = bold(logType.color ? logType.color(label) : label);
    }
    if (message instanceof Error) {
      if (message.stack) {
        let [name, ...rest] = message.stack.split("\n");
        if (name.startsWith("Error: ")) {
          name = name.slice(7);
        }
        text = `${name}
${gray(rest.join("\n"))}`;
      } else {
        text = message.message;
      }
    } else if (logType.level === "error" && typeof message === "string") {
      let lines = message.split("\n");
      text = lines.map((line) => isErrorStackMessage(line) ? gray(line) : line).join("\n");
    } else {
      text = `${message}`;
    }
    console.log(label.length ? `${label} ${text}` : text, ...args);
  };
  let logger2 = {
    greet: (message) => log("log", gradient(message))
  };
  Object.keys(LOG_TYPES).forEach((key) => {
    logger2[key] = (...args) => log(key, ...args);
  });
  Object.defineProperty(logger2, "level", {
    get: () => maxLevel,
    set(val) {
      maxLevel = val;
    }
  });
  logger2.override = (customLogger) => {
    Object.assign(logger2, customLogger);
  };
  return logger2;
};
var logger = createLogger();

// src/logger.ts
if (process.env.DEBUG) {
  logger.level = "verbose";
}
var isDebug = () => {
  if (!process.env.DEBUG) {
    return false;
  }
  logger.level = "verbose";
  const values = process.env.DEBUG.toLocaleLowerCase().split(",");
  return ["rsbuild", "builder", "*"].some((key) => values.includes(key));
};
function getTime() {
  const now = /* @__PURE__ */ new Date();
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  return `${hours}:${minutes}:${seconds}`;
}
var debug = (message) => {
  if (isDebug()) {
    const result = typeof message === "string" ? message : message();
    const time = import_picocolors.default.gray(`${getTime()}`);
    logger.debug(`${time} ${result}`);
  }
};

// src/reduceConfigs.ts
function reduceConfigs({
  initial,
  config,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject(config)) {
    return isPlainObject(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction(config)) {
    return config(initial) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigs({ initial: initial2, config: config2, mergeFn }),
      initial
    );
  }
  return config ?? initial;
}
function reduceConfigsWithContext({
  initial,
  config,
  ctx,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject(config)) {
    return isPlainObject(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction(config)) {
    return config(initial, ctx) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigsWithContext({ initial: initial2, config: config2, ctx, mergeFn }),
      initial
    );
  }
  return config ?? initial;
}
async function reduceConfigsAsyncWithContext({
  initial,
  config,
  ctx,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject(config)) {
    return isPlainObject(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction(config)) {
    return await config(initial, ctx) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigsWithContext({ initial: initial2, config: config2, ctx, mergeFn }),
      initial
    );
  }
  return config ?? initial;
}
function reduceConfigsMergeContext({
  initial,
  config,
  ctx,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject(config)) {
    return isPlainObject(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction(config)) {
    return config({ value: initial, ...ctx }) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigsMergeContext({
        initial: initial2,
        config: config2,
        ctx,
        mergeFn
      }),
      initial
    );
  }
  return config ?? initial;
}

// src/chain.ts
var import_rspack_chain = __toESM(require("../compiled/rspack-chain/index.js"));
async function getBundlerChain() {
  const bundlerChain = new import_rspack_chain.default();
  return bundlerChain;
}
async function modifyBundlerChain(context, utils) {
  debug("modify bundler chain");
  const bundlerChain = await getBundlerChain();
  const [modifiedBundlerChain] = await context.hooks.modifyBundlerChain.call(
    bundlerChain,
    utils
  );
  if (context.config.tools?.bundlerChain) {
    for (const item of castArray(context.config.tools.bundlerChain)) {
      await item(modifiedBundlerChain, utils);
    }
  }
  debug("modify bundler chain done");
  return modifiedBundlerChain;
}
var CHAIN_ID = {
  /** Predefined rules */
  RULE: {
    /** Rule for .mjs */
    MJS: "mjs",
    /** Rule for fonts */
    FONT: "font",
    /** Rule for images */
    IMAGE: "image",
    /** Rule for media */
    MEDIA: "media",
    /** Rule for js */
    JS: "js",
    /** Rule for data uri encoded javascript */
    JS_DATA_URI: "js-data-uri",
    /** Rule for ts */
    TS: "ts",
    /** Rule for css */
    CSS: "css",
    /** Rule for less */
    LESS: "less",
    /** Rule for sass */
    SASS: "sass",
    /** Rule for stylus */
    STYLUS: "stylus",
    /** Rule for svg */
    SVG: "svg",
    /** Rule for pug */
    PUG: "pug",
    /** Rule for Vue */
    VUE: "vue",
    /** Rule for yaml */
    YAML: "yaml",
    /** Rule for wasm */
    WASM: "wasm",
    /** Rule for svelte */
    SVELTE: "svelte"
  },
  /** Predefined rule groups */
  ONE_OF: {
    SVG: "svg",
    SVG_URL: "svg-asset-url",
    SVG_ASSET: "svg-asset",
    SVG_REACT: "svg-react",
    SVG_INLINE: "svg-asset-inline"
  },
  /** Predefined loaders */
  USE: {
    /** ts-loader */
    TS: "ts",
    /** css-loader */
    CSS: "css",
    /** sass-loader */
    SASS: "sass",
    /** less-loader */
    LESS: "less",
    /** stylus-loader */
    STYLUS: "stylus",
    /** url-loader */
    URL: "url",
    /** pug-loader */
    PUG: "pug",
    /** vue-loader */
    VUE: "vue",
    /** swc-loader */
    SWC: "swc",
    /** svgr */
    SVGR: "svgr",
    /** plugin-image-compress svgo-loader */
    SVGO: "svgo",
    /** yaml-loader */
    YAML: "yaml",
    /** babel-loader */
    BABEL: "babel",
    /** style-loader */
    STYLE: "style-loader",
    /** svelte-loader */
    SVELTE: "svelte",
    /** esbuild-loader */
    ESBUILD: "esbuild",
    /** postcss-loader */
    POSTCSS: "postcss",
    /** lightningcss-loader */
    LIGHTNINGCSS: "lightningcss",
    /** ignore-css-loader */
    IGNORE_CSS: "ignore-css",
    /** css-modules-typescript-loader */
    CSS_MODULES_TS: "css-modules-typescript",
    /** CssExtractRspackPlugin.loader */
    MINI_CSS_EXTRACT: "mini-css-extract",
    /** resolve-url-loader */
    RESOLVE_URL: "resolve-url-loader",
    /** plugin-image-compress.loader */
    IMAGE_COMPRESS: "image-compress"
  },
  /** Predefined plugins */
  PLUGIN: {
    /** HotModuleReplacementPlugin */
    HMR: "hmr",
    /** CopyWebpackPlugin */
    COPY: "copy",
    /** HtmlWebpackPlugin */
    HTML: "html",
    /** ESLintWebpackPlugin */
    ESLINT: "eslint",
    /** DefinePlugin */
    DEFINE: "define",
    /** ProgressPlugin */
    PROGRESS: "progress",
    /** AppIconPlugin */
    APP_ICON: "app-icon",
    /** WebpackManifestPlugin */
    MANIFEST: "webpack-manifest",
    /** ForkTsCheckerWebpackPlugin */
    TS_CHECKER: "ts-checker",
    /** InlineChunkHtmlPlugin */
    INLINE_HTML: "inline-html",
    /** WebpackBundleAnalyzer */
    BUNDLE_ANALYZER: "bundle-analyze",
    /** ModuleFederationPlugin */
    MODULE_FEDERATION: "module-federation",
    /** HtmlBasicPlugin */
    HTML_BASIC: "html-basic-plugin",
    /** htmlPreconnectPlugin */
    HTML_PRECONNECT: "html-preconnect-plugin",
    /** htmlDnsPrefetchPlugin */
    HTML_DNS_PREFETCH: "html-dns-prefetch-plugin",
    /** htmlPrefetchPlugin */
    HTML_PREFETCH: "html-prefetch-plugin",
    /** htmlPreloadPlugin */
    HTML_PRELOAD: "html-preload-plugin",
    /** CssExtractRspackPlugin */
    MINI_CSS_EXTRACT: "mini-css-extract",
    /** VueLoaderPlugin */
    VUE_LOADER_PLUGIN: "vue-loader-plugin",
    /** ReactFastRefreshPlugin */
    REACT_FAST_REFRESH: "react-fast-refresh",
    /** ProvidePlugin for node polyfill */
    NODE_POLYFILL_PROVIDE: "node-polyfill-provide",
    /** WebpackSRIPlugin */
    SUBRESOURCE_INTEGRITY: "subresource-integrity",
    /** AssetsRetryPlugin */
    ASSETS_RETRY: "assets-retry",
    /** AsyncChunkRetryPlugin */
    ASYNC_CHUNK_RETRY: "async-chunk-retry",
    /** AutoSetRootFontSizePlugin */
    AUTO_SET_ROOT_SIZE: "auto-set-root-size",
    /** VueLoader15PitchFixPlugin */
    VUE_LOADER_15_PITCH_FIX_PLUGIN: "vue-loader-15-pitch-fix"
  },
  /** Predefined minimizers */
  MINIMIZER: {
    /** SwcJsMinimizerRspackPlugin */
    JS: "js",
    /** SwcCssMinimizerRspackPlugin */
    CSS: "css",
    /** ESBuildPlugin */
    ESBUILD: "js-css",
    /** SWCPlugin */
    SWC: "swc"
  },
  /** Predefined resolve plugins */
  RESOLVE_PLUGIN: {
    /** ModuleScopePlugin */
    MODULE_SCOPE: "module-scope",
    /** TsConfigPathsPlugin */
    TS_CONFIG_PATHS: "ts-config-paths"
  }
};
function applyScriptCondition({
  rule,
  chain,
  config,
  context,
  includes,
  excludes
}) {
  rule.include.add({
    and: [context.rootPath, { not: NODE_MODULES_REGEX }]
  });
  rule.include.add(TS_AND_JSX_REGEX);
  const target = castArray(chain.get("target"));
  const legacyTarget = ["es5", "es6", "es2015", "es2016"];
  if (legacyTarget.some((item) => target.includes(item))) {
    rule.include.add(/[\\/]@rsbuild[\\/]core[\\/]dist[\\/]/);
  }
  for (const condition of [...includes, ...config.source.include || []]) {
    rule.include.add(condition);
  }
  for (const condition of [...excludes, ...config.source.exclude || []]) {
    rule.exclude.add(condition);
  }
}
function chainToConfig(chain) {
  const config = chain.toConfig();
  const { entry } = config;
  if (!isPlainObject(entry)) {
    return config;
  }
  const formattedEntry = {};
  for (const [entryName, entryValue] of Object.entries(entry)) {
    const entryImport = [];
    let entryDescription = null;
    for (const item of castArray(entryValue)) {
      if (typeof item === "string") {
        entryImport.push(item);
        continue;
      }
      if (item.import) {
        entryImport.push(...castArray(item.import));
      }
      if (entryDescription) {
        Object.assign(entryDescription, item);
      } else {
        entryDescription = item;
      }
    }
    formattedEntry[entryName] = entryDescription ? {
      ...entryDescription,
      import: entryImport
    } : entryImport;
  }
  config.entry = formattedEntry;
  return config;
}

// src/url.ts
var import_node_path2 = require("path");
var import_node_url = require("url");
var normalizeUrl = (url) => url.replace(/([^:]\/)\/+/g, "$1");
var canParse = (url) => {
  try {
    new import_node_url.URL(url);
    return true;
  } catch {
    return false;
  }
};
var urlJoin = (base, path2) => {
  const fullUrl = new import_node_url.URL(base);
  fullUrl.pathname = import_node_path2.posix.join(fullUrl.pathname, path2);
  return fullUrl.toString();
};
var withPublicPath = (str, base) => {
  if (str.startsWith("//")) {
    return str;
  }
  if (canParse(str)) {
    return str;
  }
  if (base.startsWith("http")) {
    return urlJoin(base, str);
  }
  if (base.startsWith("//")) {
    return urlJoin(`https:${base}`, str).replace("https:", "");
  }
  return import_node_path2.posix.join(base, str);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CHAIN_ID,
  DEFAULT_ASSET_PREFIX,
  DEFAULT_BROWSERSLIST,
  JS_REGEX,
  NODE_MODULES_REGEX,
  RspackChain,
  SCRIPT_REGEX,
  TARGET_ID_MAP,
  TS_AND_JSX_REGEX,
  TS_REGEX,
  addTrailingSlash,
  applyScriptCondition,
  applyToCompiler,
  browserslistToESVersion,
  camelCase,
  canParse,
  castArray,
  chainToConfig,
  cloneDeep,
  color,
  createCacheGroups,
  createDependenciesRegExp,
  createVirtualModule,
  debounce,
  debug,
  deepmerge,
  fse,
  generateScriptTag,
  getBrowserslist,
  getBrowserslistWithDefault,
  getBundlerChain,
  getCoreJsVersion,
  getDistPath,
  getFilename,
  getJsSourceMap,
  getNodeEnv,
  getPublicPathFromCompiler,
  getSharedPkgCompiledPath,
  isClientCompiler,
  isDebug,
  isDev,
  isFunction,
  isHtmlDisabled,
  isMultiCompiler,
  isNil,
  isNodeCompiler,
  isObject,
  isPlainObject,
  isProd,
  isRegExp,
  isServerTarget,
  isString,
  isTest,
  isURL,
  isUndefined,
  isUsingHMR,
  isWebTarget,
  kebabCase,
  logger,
  modifyBundlerChain,
  normalizeUrl,
  onCompileDone,
  partition,
  pick,
  prettyTime,
  reduceConfigs,
  reduceConfigsAsyncWithContext,
  reduceConfigsMergeContext,
  reduceConfigsWithContext,
  removeLeadingSlash,
  removeTailingSlash,
  setNodeEnv,
  upperFirst,
  withPublicPath
});
